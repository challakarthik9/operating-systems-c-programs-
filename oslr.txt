menu driven algo type example
///////////////////////
#include <stdio.h> 
int input(); 
void output(float); 
int main() 
{ 
    float result; 
    int choice, num; 
    printf("Press 1 to calculate area of circle\n"); 
    printf("Press 2 to calculate area of square\n"); 
    printf("Press 3 to calculate area of sphere\n"); 
    printf("Enter your choice:\n"); 
    choice = input(); 
      
    switch (choice) { 
    case 1: { 
        printf("Enter radius:\n"); 
        num = input(); 
        result = 3.14 * num * num; 
        printf("Area of sphere="); 
        output(result); 
        break; 
    } 
    case 2: { 
        printf("Enter side of square:\n"); 
        num = input(); 
        result = num * num; 
        printf("Area of square="); 
        output(result); 
        break; 
    } 
    case 3: { 
        printf("Enter radius:\n"); 
        num = input(); 
        result = 4 * (3.14 * num * num); 
        printf("Area of sphere="); 
        output(result); 
        break; 
    } 
    default: 
        printf("wrong Input\n"); 
    } 
    return 0; 
} 
int input() 
{ 
    int number; 
    scanf("%d", &number); 
    return (number); 
} 
  
void output(float number) 
{ 
    printf("%f", number); 
} 



///////////////////////
#include<stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int choice, num, i;
    unsigned long int fact;

    while(1)
    {
        printf("1. Factorial \n");
        printf("2. Prime\n");
        printf("3. Odd\\Even\n");
        printf("4. Exit\n\n\n");
        printf("Enter your choice :  ");
        scanf("%d",&choice);
        
        switch(choice)
        {
            case 1:
                printf("Enter number:\n");
                scanf("%d", &num);
                fact = 1;
                for(i = 1; i <= num; i++)
                {
                    fact = fact*i;
                }
                printf("\n\nFactorial value of %d is = %lu\n\n\n",num,fact);
                break;
        
            case 2:
                printf("Enter number:\n");
                scanf("%d", &num);
                if(num == 1)
                printf("\n1 is neither prime nor composite\n\n");
                for(i = 2; i < num; i++)
                {
                    if(num%i == 0)
                    {
                        printf("\n%d is not a prime number\n\n", num);
                        break;
                    }
                
                }
                /*
                    Not divisible by any number other 
                    than 1 and itself
                */
                if(i == num) 
                {
                    printf("\n\n%d is a Prime number\n\n", num);
                    break;
                }
        
            case 3:
                printf("Enter number:\n");
                scanf("%d", &num);
        
                if(num%2 == 0) // 0 is considered to be an even number
                    printf("\n\n%d is an Even number\n\n",num);
                else
                    printf("\n\n%d is an Odd number\n\n",num);
                break;
        
            case 4:
                printf("\n\n\t\t\tCoding is Fun !\n\n\n");
                exit(0);    // terminates the complete program execution
        }
    }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

////////////////////////
#include<stdio.h>
#include<conio.h>
#include<math.h>

void fcfs(int a[]);
void sstf(int a[]);
void scan(int a[]);



void main()
{
int n, a[10], ch, i;
printf("enter 10 cylinders numbers");
for(i=0; i<10; i++)
{
scanf("%d", &a[i]);
}



run:
{


printf("\n\n which algo do u want to use?");
printf("\n1) FCFS\n2)SSTF\n3)SCAN\n4)EXIT\n");
scanf("%d", &ch);

switch(ch)
{


      case 1: fcfs(a);
	      goto run;

      case 2: sstf(a);
	      goto run;

      case 3: scan(a);
	      goto run;

      case 4: exit(0);

      default: printf("please enter a valid choice");
	       goto run;

      }
      }
getch();
}

void fcfs(int a[])
{
int order[10], i, x, count=0, ptr;

printf("\n current pointer location");
scanf("%d", &ptr);
for(i=0; i<10; i++)
{
order[i] = a[i];
}
x= ptr- a[0];
if(x>0)
count=x;
else
count= -x;


for(i=1; i<10; i++)
{
x= a[i] - a[i-1];
if(x<0)
count =count+ (-x);
else
count =count+  x;
}

printf("Execution order:\n");
for(i=0; i<10; i++)
{
printf("%d ", order[i]);
}

printf("\nTotal cost : %d", count);
}


void sstf(int a[])
{
int i, j, ptr, count, x, m=9, b[10], min=9999, temp;
printf("\n current pointer location");
scanf("%d", &ptr);
j=ptr;
for(i=0; i<10; i++)
{
b[i] =a[i];
}

while(m>=0)
{
min=9999;
i=m;
while(i>=0)
{
if(abs(b[i]-ptr)<min)
{
min= abs(b[i]-ptr);
x=i;

}
--i;
}
ptr=a[x];
temp= b[x];
b[x] = b[m];
b[m] = temp;
--m;
}

count = abs(j-b[9]);
printf("execution order:\n");
for(i=9; i>=1; i--)
{
printf("%d ", b[i]);
count =count+ abs(b[i]-b[i-1]);
}
printf("%d ", b[0]);
printf("\nTotal cost : %d", count);



}


void scan(int a[])
{
  int ptr, b[11], i, j, min, x, temp;
 printf("\n current pointer location");
scanf("%d", &ptr);
b[0]= ptr;
for(i=0; i<10; i++)
{
b[i+1]= a[i];
}

for(i=0; i<10; i++)
{
min= i;
for(j=i+1; j<11; j++)
{
if(b[j]<b[min])
{
min = j;
}
}
temp = b[i];
b[i] = b[min];
b[min] = temp;
}


i=0;
while(b[i]!=ptr && i<11)
{
i++;
}
printf("\nExecution order :");
x=i;
i=x+1;
while(i!=x)
{
printf(" %d", b[i]);
i= (i+1)%11;
}


}
//////////////////////////////////////////////////

#include<stdio.h>
#include<pthread.h>
#include<semaphore.h>
int buf[5],f,r;
sem_t mutex,full,empty;
void *produce(void *arg)
{
    int i;
    for(i=0;i<10;i++)
    {
        sem_wait(&empty);
        sem_wait(&mutex);
        printf("produced item is %d\n",i);
        buf[(++r)%5]=i;
        Sleep(1);
        sem_post(&mutex);
                sem_post(&full);
        printf("full %u\n",full);
    }
}
void *consume(void *arg)
{
        int item,i;
        for(i=0;i<10;i++)
        {
                sem_wait(&full);
        printf("full %u\n",full);
                sem_wait(&mutex);
                item=buf[(++f)%5];
                printf("consumed item is %d\n",item);
                Sleep(1);
                sem_post(&mutex);
                sem_post(&empty);
        }
}
main()
{
    pthread_t tid1,tid2;
    sem_init(&mutex,0,1);
    sem_init(&full,0,1);
    sem_init(&empty,0,5);
    pthread_create(&tid1,NULL,produce,NULL);
        pthread_create(&tid2,NULL,consume,NULL);
    pthread_join(tid1,NULL);
    pthread_join(tid2,NULL);
}



///////////////normal producer consumer problem


ALGORITHM
Step1: START.
Step2: Initiate a menu driven program for the Producer Consumer problem. 
Step3: Ask the user to input his choice from (1. Producer. 2. Consumer. 3. Exit)
Step4: Read the buffer size. 
Step5: If input ==1, check for the buffer. If full=true, display, “Sorry, buffer is full, producer has to wait.” If full=false, decrease the empty by one and add produce in the buffer. Producer has produced!
Step6: If input==2, check for the buffer. If empty==true, display, “Buffer is empty, consumer cannot consume!”. If not, increment the remaining by one and decrement the filled by one. Consumer has consumed!
Step7: If input==3, exit.

#include<stdio.h>
#include<stdlib.h>

int main()
{
    int var=1;
    int full=0;
    int empty;
    int x;
    int m=0;
    int n;

    printf("Enter the size of the Buffer Memory: ");
    scanf("%d",&m);

    empty=m;

    printf("\n1.Producer\n2.Consumer\n3.Exit");
    while(1)
    {
        printf("\nEnter your choice:");
        scanf("%d",&n);
        switch(n)
        {

            case 1:
                if((var==1)&&(empty!=0))
                {
                    --var;
                    ++full;
                    --empty;
                    x++;
                    printf("\nProducer produces the item",x);
                    ++var;
                }
                else
                    printf("Buffer is full!!");
                break;

            case 2:
                if((var==1)&&(full!=0))
                {
                    --var;
                    --full;
                    ++empty;
                    printf("\nConsumer consumes item ",x);
                    x--;
                    ++var;
                }
                else
                    printf("Buffer is empty!!");
                break;

            case 3:
                exit(0);
                break;
        }
    }
    return 0;
}





///////////////////////////////#producer consumer problem using semaphore
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>
#include<semaphore.h> /* sem_t */
#include<stdlib.h>

#define BUF_SIZE 2

struct buffer {
        int data;
};

struct buffer buf[BUF_SIZE];

sem_t fill, empty;

int value, i;

void *producer(void *data);
void *consumer(void *data);

int main(void)
{
    int sel, prod_data, cons_data;
    int k;

    if (sem_init(&empty, 0, BUF_SIZE)) {
        printf("Error: semaphore not initialize\n");
        return -1;
    }
    if (sem_init(&fill, 0, 0)) {
        printf("Error: semaphore not initialize\n");
        return -1;
    }

    while (1) {
        printf(".........................................................\n");
        printf("Selection\n");
        printf("Producer : 1 | Consumer : 2 | Display : 3 | Exit : 0 || ");
        scanf("%d",&sel);
        printf(".........................................................\n");

        switch (sel) {
        case 1:
            sem_getvalue(&empty, &value);
//          printf("Prod_e: %d\n", value);
            sem_getvalue(&fill, &value);
//          printf("Prod_f: %d\n", value);
            printf("\nProducer\n");
            pthread_t prod_t;
            printf("Enter data:");
            scanf("%d", &prod_data);
            if (pthread_create(&prod_t, NULL, producer, (void *) &prod_data)) {
                printf("Error: thread not created\n");
                return -1;
            }
            break;
        case 2:
            printf("\nConsumer\n");
            sem_getvalue(&empty, &value);
//          printf("Cons_e: %d\n", value);
            sem_getvalue(&fill, &value);
//          printf("Cons_f: %d\n", value);
            pthread_t con_t;
            if (pthread_create(&con_t, NULL, consumer, (void *) &cons_data)) {
                printf("Error: thread not created\n");
                return -1;
            }
            if (i == 0) {
                printf("Buffer empty\n");
                break;
            }
//              sleep(1); // if commented then synchronization issue
            printf("Consume data: %d\n", cons_data);
            break;
        case 3:
                if (i == 0) {
                    printf("Buffer empty\n");
                    break;
                }
                for (k = 0; k < i; k++)
                    printf("buf[%d]: %d\n", k, buf[k].data);
                break;
        case 0:
            sem_destroy(&fill);
            sem_destroy(&empty);
            exit (0);
            break;
        }
    }
    sem_destroy(&fill);
    sem_destroy(&empty);
    return 0;
}

void *producer(void *arg)
{
    int data = *(int *) arg;

    if (sem_wait(&empty)) { /* wait */
        printf("Error: sem wait fail\n");
        pthread_exit(NULL);
    }

    buf[i].data = data;
    i++;

    if (sem_post(&fill)) { /* post */
        printf("Error: sem wait fail\n");
        pthread_exit(NULL);
    }

    pthread_exit(NULL);
}

void *consumer(void *arg)
{

    if (sem_wait(&fill)) { /* wait */
        printf("Error: sem wait fail\n");
        pthread_exit(NULL);
    }

    i--;
    *(int *) arg = buf[i].data;

    if (sem_post(&empty)) { /* post */
        printf("Error: sem wait fail\n");
        pthread_exit(NULL);
    }
    pthread_exit(NULL);
}



pthread_join(con_t, NULL); or use this




//////////////////////////////LRU PAGE REPLACEMENT
#include<stdio.h>
 
int findLRU(int time[], int n){
    int i, minimum = time[0], pos = 0;
 
    for(i = 1; i < n; ++i){
        if(time[i] < minimum){
            minimum = time[i];
            pos = i;
        }
    }
    
    return pos;
}
 
int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], counter = 0, time[10], flag1, flag2, i, j, pos, faults = 0;
    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);
    
    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);
    
    printf("Enter reference string: ");
    
    for(i = 0; i < no_of_pages; ++i){
        scanf("%d", &pages[i]);
    }
    
    for(i = 0; i < no_of_frames; ++i){
        frames[i] = -1;
    }
    
    for(i = 0; i < no_of_pages; ++i){
flag1 = flag2 = 0;
        
        for(j = 0; j < no_of_frames; ++j){
            if(frames[j] == pages[i]){
                counter++;
                time[j] = counter;
                   flag1 = flag2 = 1;
                   break;
               }
        }
        
        if(flag1 == 0){
            for(j = 0; j < no_of_frames; ++j){
                if(frames[j] == -1){
                    counter++;
                    faults++;
                    frames[j] = pages[i];
                    time[j] = counter;
                    flag2 = 1;
                    break;
                }
            }    
        }
        
        if(flag2 == 0){
            pos = findLRU(time, no_of_frames);
            counter++;
            faults++;
            frames[pos] = pages[i];
            time[pos] = counter;
        }
        
        printf("\n");
        
        for(j = 0; j < no_of_frames; ++j){
            printf("%d\t", frames[j]);
        }
    }
    
    printf("\n\nTotal Page Faults = %d", faults);
    
    return 0;
}


///////////////dining phiosophers problem
ALGORITHM
Step1: START.
Step2: Read the Number of Philosophers from the user.
Step3: Initiate three arrays, P[30],C[30],eat[30], to store corresponding values of the philosopher’s table, Chopsticks and the condition if the philosopher was eating or not.
Step4: Initiate a menu driven code to ask the user regarding the position of the philosopher and the task to be performed.
Step5: If task==eating, check the status of the chopstick for the [i] and [i+1]th position. If both have status=0(or unused), proceed the philosopher to eat.
Step6: If either chopstick status=1, display ”The philosopher cannot eat, since the chopsticks are occupied”.
Step7: Call the menu driven program recursively.

#include<stdio.h>
#include<stdlib.h>
int p[10];
int c[10];
int eat[10];
int n=0,i,t,cases;
int main()
{
    printf("enter the total number of philosphers at the table:");
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        p[i]=i;
        c[i]=i;
        eat[i]=0;
    }
    printf("enter the philosopher's number:");
    while(1)
    {
        scanf("%d",&t);
        printf("enter 1 if has to eat \n enter 2 if philospher has to stop eating");
        scanf("%d",&cases);
        switch(cases)
        {
        case 1:
            if(t!=n-1)
            {
                if(eat[t+1]==0 && eat[i]==0)
                {
                    printf("\n the philosopher is eating:");
                    printf("\n the chopstick %d and chopstick %d is being used",c[t],c[t+1]);
                    eat[t+1]=1;
                    eat[t]=1;
                }
                else if(eat[t+1]==1 && eat[t]==0)
                    {
                        printf("\n the philospher has to wait");
                        printf("\n the chopstick %d is not free",c[t+1]);
                    }
                    else if(eat[t]==1 && eat[t+1]==0)
                    {
                        printf("\n the philospher has to wait");
                        printf("\n the chopstick %d is not free",c[t]);
                    }
                    else if(eat[t+1]==1 && eat[1]==1)
                    {
                        printf("\n the philospher is eating already");
                    }
            }
            else if(t==n-1)
            {
                if(eat[0]==0 && eat[t]==0)
                {
                    printf("the philosopher is eating:");
                    printf("\n the chopstick %d and chopstick %d is being used",c[t],c[0]);
                    eat[0]=1;
                    eat[i]=1;
                }
                else if(eat[0]==1 && eat[t]==0)
                {
                    printf("\n the philosopher has to wait");
                    printf("\n the chopstick %d is already in use",c[0]);
                }
                else if(eat[t]==1 && eat[0]==0)
                {
                    printf("\n the philosopher has to wait");
                    printf("\n the chopstick %d is already in use",c[t]);
                }
                else if(eat[t]==1 && eat[0]==1)
                {
                    printf("\n the philosopher is already eating");
                }
            }
            break;

        case 2:
            if(t!=n-1)
            {
                if(eat[t+1]==1 && eat[t]==1)
                {
                    printf("the philosopher has stopped eating");
                    printf("\n the chopstick %d and %d are now free",c[t],c[t+1]);
                    eat[t+1]=0;
                    eat[t]=0;
                }
                else

                    {
                    printf("\n the philosopher was not eating");

                }
            }
                else if (t==n)
                {
                    if(eat[0]==1 && eat[t]==1)
                    {
                        printf("the philosopher has stopped eating");
                        printf("\n the chopstick %d and %d are now free",c[t],c[0]);
                        eat[t+1]=0;
                        eat[t]=0;
                    }
                    else
                    {
                        printf("The philosopher was not eating");
                    }
                }
                break;
        case 3:
            exit(0);

            }
    }
}



////////////////reader writers problem using wait mutex
Step1: START.
Step2: Initiate a Menu driven Program with the following cases: 1. Start Writing. 2. Finish Writing. 3. Start Reading. 4. Finish Reading. 5. Exit.
Step3: If input=1, Initiation of writing needs to be done.
Check if(wrt=0). If true, terminate the process.
If not, Writing process is initiated.
Step4: If Input==2, Termination of Writing is requested. Increment value of wrt and process is brought out of the critical section.
Step5: If input==3, Request for Initiation of Reading is presented. Check if (wrt=0). If true, process cannot enter into the Reading section. Processed passed on to the waiting queue. 
If wrt=0, process initiated reading, readcnt is incremented by 1.
Step6: if input==4, termination of reading by a reader is requested. 
Check if wrt=0. Decrement the val of readcnt by 1. If after decrement, readcnt=0, this was the last reader. Thus, Increment val of wrt by 1. Critical section is unlocked for writer.
Step7: If input==5, exit.
Step8: END.


#include<stdio.h>
int mutex=1,wrt=1;
int wait(int s)
{
    while(s<=0);
    return(s--);
}

int signal(int s)
{
    return(s++);
}

int main()
{
    int n=0;
    int i=1;
    int readcnt=0;
    printf("MENU DRIVEN PROGRAM FOR READERS AND WRITERS PROGRAM\n\n");
    printf("1.Enter Write\n2.Exit write\n3.Enter read\n4.Exit Read\n\n");

    while(i==1)
    {
        printf("Enter your choice:");
        scanf("%d",&n);
        if(n==1)
        {
            if(readcnt>1)
            {
                printf("Write cannot be performed.Reading in process.");

            }
            else{
                //request by writer to access critical section to write wait(wrt);
                //cs locked for all other writers
                wait(wrt);
                printf("Writing in process\n");

                printf("Enter your choice:");
                scanf("%d",&n);
                if(n==2)
                {
                    signal(wrt);
                    printf("WRITING performed!\n\n");
                    continue;
                }

                else if(n==3)
                {
                    printf("writer in process.Reading cannot be performed!\n\n");

                }
                else if(n==1)
                {
                    printf("Writing already in process.New writing process cannot be performed\n\n");

                }

            }
        }
        else if(n==2)
        {
            printf("NO writing process in action.\nAction terminated.\n\n");

        }
        else if(n==3)
        {
            wait(mutex);
            readcnt++;
            if(readcnt==1)
                wait(wrt);
            signal(mutex);

            printf("Reading is performed!\n");
            printf("No of readers in the reading section=%d \n\n",readcnt);

        }
        if(n==4)
        {
            if(readcnt>=1)
        {

            wait(mutex);
            readcnt--;
            if(readcnt==0)
            signal(wrt);
            printf("reader exited\n");
            printf("no of readers in the reading section=%d\n\n",readcnt);
        }

        else if(readcnt<1)
        {
            printf("Reader list empty!");

        }
signal(mutex);
        }
        else if(n==5)
        {
            printf("Code Terminated.\n\n");
            break;
        }
    }
}


///////////////////

///readers writer using mutex


#include<pthread.h>
#include<semaphore.h>
#include<Windows.h>
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

pthread_mutex_t x,w_sem;
pthread_t tid;
int readcount;

void intialize()
{
    pthread_mutex_init(&x,NULL);
    pthread_mutex_init(&w_sem,NULL);
    readcount=0;
}

void * reader (void * param)
{
    int waittime;
    waittime = rand() % 5;
    printf("\nReader is trying to enter");
    pthread_mutex_lock(&x);
    readcount++;
    if(readcount==1)
        pthread_mutex_lock(&w_sem);
    printf("\n%d Reader is inside ",readcount);
    pthread_mutex_unlock(&x);
    Sleep(waittime);
    pthread_mutex_lock(&x);
    readcount--;
    if(readcount==0)
        pthread_mutex_unlock(&w_sem);
    pthread_mutex_unlock(&x);
    printf("\nReader is Leaving");
}

void * writer (void * param)
{
    int waittime;
    waittime=rand() % 3;
    printf("\nWriter is trying to enter");
    pthread_mutex_lock(&w_sem);
    printf("\nWrite has entered");
    Sleep(waittime);
    pthread_mutex_unlock(&w_sem);
    printf("\nWriter is leaving");
    Sleep(30);
    exit(0);
}

int main()
{
    int n1,n2,i;
    printf("\nEnter the no of readers: ");
    scanf("%d",&n1);
    printf("\nEnter the no of writers: ");
    scanf("%d",&n2);
    for(i=0;i<n1;i++)
        pthread_create(&tid,NULL,reader,NULL);
    for(i=0;i<n2;i++)
        pthread_create(&tid,NULL,writer,NULL);
    Sleep(30);
    exit(0);
}


//////reader and writers sleep function
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>
#include<semaphore.h>
#include<Windows.h>

sem_t mutex,writeblock;
int data = 0,rcount = 0;

void *reader(void *arg)
{
  int f;
  f = ((int)arg);
  sem_wait(&mutex);
  rcount = rcount + 1;
  if(rcount==1)
   sem_wait(&writeblock);
  sem_post(&mutex);
  printf("Data read by the reader%d is %d\n",f,data);
    Sleep(1);
  sem_wait(&mutex);
  rcount = rcount - 1;
  if(rcount==0)
   sem_post(&writeblock);
  sem_post(&mutex);
}

void *writer(void *arg)
{
  int f;
  f = ((int) arg);
  sem_wait(&writeblock);
  data++;
  printf("Data writen by the writer%d is %d\n",f,data);
  Sleep(1);
  sem_post(&writeblock);
}

int main()
{
  int i,b;
  pthread_t rtid[5],wtid[5];
  sem_init(&mutex,0,1);
  sem_init(&writeblock,0,1);
  for(i=0;i<=2;i++)
  {
    pthread_create(&wtid[i],NULL,writer,(void *)i);
    pthread_create(&rtid[i],NULL,reader,(void *)i);
  }
  for(i=0;i<=2;i++)
  {
    pthread_join(wtid[i],NULL);
    pthread_join(rtid[i],NULL);
  }
  return 0;
}

////reader and writer using semaphore
#include<pthread.h>
#include<semaphore.h>
#include<Windows.h>
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

pthread_mutex_t x,wsem;
pthread_t tid;
int readcount;

void intialize()
{
    pthread_mutex_init(&x,NULL);
    pthread_mutex_init(&wsem,NULL);
    readcount=0;
}

void * reader (void * param)
{
    int waittime;
    waittime = rand() % 5;
    printf("\nReader is trying to enter");
    pthread_mutex_lock(&x);
    readcount++;
    if(readcount==1)
        pthread_mutex_lock(&wsem);
    printf("\n%d Reader is inside ",readcount);
    pthread_mutex_unlock(&x);
    Sleep(waittime);
    pthread_mutex_lock(&x);
    readcount--;
    if(readcount==0)
        pthread_mutex_unlock(&wsem);
    pthread_mutex_unlock(&x);
    printf("\nReader is Leaving");
}

void * writer (void * param)
{
    int waittime;
    waittime=rand() % 3;
    printf("\nWriter is trying to enter");
    pthread_mutex_lock(&wsem);
    printf("\nWrite has entered");
    Sleep(waittime);
    pthread_mutex_unlock(&wsem);
    printf("\nWriter is leaving");
    Sleep(30);
    exit(0);
}

int main()
{
    int n1,n2,i;
    printf("\nEnter the no of readers: ");
    scanf("%d",&n1);
    printf("\nEnter the no of writers: ");
    scanf("%d",&n2);
    for(i=0;i<n1;i++)
        pthread_create(&tid,NULL,reader,NULL);
    for(i=0;i<n2;i++)
        pthread_create(&tid,NULL,writer,NULL);
    Sleep(30);
    exit(0);
}


///producer and consumer using sempahore
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <conio.h>

/*
use the pthread flag with gcc to compile this code
~$ gcc -pthread producer_consumer.c -o producer_consumer
*/


pthread_t *producers;
pthread_t *consumers;

sem_t buf_mutex,empty_count,fill_count;

int *buf,buf_pos=-1,prod_count,con_count,buf_len;


int produce(pthread_t self){
	int i = 0;
	int p = 1 + rand()%40;
	while(!pthread_equal(*(producers+i),self) && i < prod_count){
		i++;
	}
	printf("Producer %d produced %d \n",i+1,p);
	return p;
}


void consume(int p,pthread_t self){
	int i = 0;
	while(!pthread_equal(*(consumers+i),self) && i < con_count){
		i++;
	}

	printf("Buffer:");
	for(i=0;i<=buf_pos;++i)
		printf("%d ",*(buf+i));
	printf("\nConsumer %d consumed %d \nCurrent buffer len: %d\n",i+1,p,buf_pos);

}


void* producer(void *args){

	while(1){
		int p = produce(pthread_self());
		sem_wait(&empty_count);
		sem_wait(&buf_mutex);
		++buf_pos;			// critical section
		*(buf + buf_pos) = p;
		sem_post(&buf_mutex);
		sem_post(&fill_count);
		Sleep(1 + rand()%3);
	}

	return NULL;
}


void* consumer(void *args){
	int c;
	while(1){
		sem_wait(&fill_count);
		sem_wait(&buf_mutex);
		c = *(buf+buf_pos);
		consume(c,pthread_self());
		--buf_pos;
		sem_post(&buf_mutex);
		sem_post(&empty_count);
		Sleep(1+rand()%5);
	}

	return NULL;
}

int main(void){

	int i,err;

	srand(time(NULL));

	sem_init(&buf_mutex,0,1);
	sem_init(&fill_count,0,0);

	printf("Enter the number of Producers:");
	scanf("%d",&prod_count);
	producers = (pthread_t*) malloc(prod_count*sizeof(pthread_t));

	printf("Enter the number of Consumers:");
	scanf("%d",&con_count);
	consumers = (pthread_t*) malloc(con_count*sizeof(pthread_t));

	printf("Enter buffer capacity:");
	scanf("%d",&buf_len);
	buf = (int*) malloc(buf_len*sizeof(int));

	sem_init(&empty_count,0,buf_len);

	for(i=0;i<prod_count;i++){
		err = pthread_create(producers+i,NULL,&producer,NULL);
		if(err != 0){
			printf("Error creating producer %d: %s\n",i+1,strerror(err));
		}else{
			printf("Successfully created producer %d\n",i+1);
		}
	}

	for(i=0;i<con_count;i++){
		err = pthread_create(consumers+i,NULL,&consumer,NULL);
		if(err != 0){
			printf("Error creating consumer %d: %s\n",i+1,strerror(err));
		}else{
			printf("Successfully created consumer %d\n",i+1);
		}
	}

	for(i=0;i<prod_count;i++){
		pthread_join(*(producers+i),NULL);
	}
	for(i=0;i<con_count;i++){
		pthread_join(*(consumers+i),NULL);
	}


	return 0;
	getch();
}



/////first prefer bankers algorithm;

#include <stdio.h>
#include<conio.h>

int present[5][5];
int max_req[5][5];
int available[5];
int allocation[5] = {0, 0, 0, 0, 0};
int max_resources[5];
int running[5];
int safe = 0;
int count = 0;
int i=0;
int j=0;
int exec;
int resources;
int processes;
int k = 1;

int main()
{
    //Scanning the Number of Processes
    printf("\nEnter number of processes: ");
    scanf("%d", &processes);

    for (i = 0; i < processes; i++)
    {
        running[i] = 1;
        count++;
    }

    //Scanning the number of Resources
    printf("\nEnter number of resources: ");
    scanf("%d", &resources);

    //Scanning the claim Vector
    printf("\nEnter Claim Vector:");
    for (i = 0; i < resources; i++)
    {
        scanf("%d", &max_resources[i]);
    }

    //Scanning the Allocation Matrix
    printf("\nEnter Allocated Resource Table:\n");
    for (i = 0; i < processes; i++)
    {
        for(j = 0; j < resources; j++)
        {
            scanf("%d", &present[i][j]);
        }
    }

    //Scanning the Max Claim Matrix
    printf("\nEnter Maximum Claim Table:\n");
    for (i = 0; i < processes; i++)
    {
        for(j = 0; j < resources; j++)
        {
            scanf("%d", &max_req[i][j]);
        }
    }

    printf("\nThe Claim Vector is: ");
    for (i = 0; i < resources; i++)
    {
        printf("\t%d", max_resources[i]);
    }

    printf("\nThe Allocated Resource Table:\n");
    for (i = 0; i < processes; i++)
    {
        for (j = 0; j < resources; j++)
        {
            printf("\t%d", present[i][j]);
        }
        printf("\n");
    }

    printf("\nThe Maximum Claim Table:\n");
    for (i = 0; i < processes; i++)
    {
        for (j = 0; j < resources; j++)
        {
            printf("\t%d", max_req[i][j]);
        }
        printf("\n");
    }

    for (i = 0; i < processes; i++)
    {
        for (j = 0; j < resources; j++)
        {
            allocation[j] += present[i][j];
        }
    }

    printf("\nAllocated resources:");
    for (i = 0; i < resources; i++)
    {
        printf("\t%d", allocation[i]);
    }

    for (i = 0; i < resources; i++)
    {
        available[i] = max_resources[i] - allocation[i];
    }

    printf("\nAvailable resources:");
    for (i = 0; i < resources; i++)
    {
        printf("\t%d", available[i]);
    }
    printf("\n");

    while (count != 0)
    {
        safe = 0;
        for (i = 0; i < processes; i++)
        {
            if (running[i])
            {
                exec = 1;
                for (j = 0; j < resources; j++)
                {
                    if (max_req[i][j] - present[i][j] > available[j])
                    {
                        exec = 0;
                        break;
                    }
                }
                if (exec)
                {
                    printf("\nProcess%d is executing\n", i + 1);
                    running[i] = 0;
                    count--;
                    safe = 1;

                    for (j = 0; j < resources; j++)
                    {
                        available[j] += present[i][j];
                    }
                    break;
                }
            }
        }
        if (!safe)
        {
            printf("\nThe processes are in unsafe state.\n");
            break;
        }
        else
        {
            printf("\nThe process is in safe state");
            printf("\nAvailable vector:");

            for (i = 0; i < resources; i++)
            {
                printf("\t%d", available[i]);
            }

            printf("\n");
        }
    }
    return 0;
    getch();
}


ALGORITHM
Step1: START.
Step2: Let Work and Finish be vectors of length ‘m’ and ‘n’ respectively.
Initialize:Work=Available, Finish [i]=false; for i=1,2,……,n

Step3: Find an i such that both
a) Finish [i]=false
b) Need_i<=work
if no such i exists goto step (4)

Step4: Work=Work + Allocation_i
Finish[i]= true
goto step(2)

Step5: If Finish[i]=true for all i,
then the system is in safe state.
Step 6: Initiate a menu driven code for the above program. 
Step 7: Read the allocation Matrix, Available matrix, Number of Resources, Number of processes, Claim matrix from the user.
Step8: Use the steps from 2 to 5 to determine whether system is in a safe state or not. If yes, display, “System is in a safe state!”, else display, “System is in unsafe state!”.
Step9: Terminate the menu.
Step10: END. 




///////another for bankers
#include<stdio.h>
#include<conio.h>
void main()
{
    int n,r,i,j,k,p,u=0,s=0,m;
    int block[10],run[10],active[10],newreq[10];
    int max[10][10],resalloc[10][10],resreq[10][10];
    int totalloc[10],totext[10],simalloc[10];
    //clrscr();
    printf("Enter the no of processes:");
    scanf("%d",&n);
    printf("Enter the no ofresource classes:");
    scanf("%d",&r);
    printf("Enter the total existed resource in each class:");
    for(k=1; k<=r; k++)
        scanf("%d",&totext[k]);
    printf("Enter the allocated resources:");
    for(i=1; i<=n; i++)
        for(k=1; k<=r; k++)
            scanf("%d",&resalloc);
    printf("Enter the process making the new request:");
    scanf("%d",&p);
    printf("Enter the requested resource:");
    for(k=1; k<=r; k++)
        scanf("%d",&newreq[k]);
    printf("Enter the process which are n blocked or running:");
    for(i=1; i<=n; i++)
    {
        if(i!=p)
        {
            printf("process %d:\n",i+1);
            scanf("%d%d",&block[i],&run[i]);
        }
    }
    block[p]=0;
    run[p]=0;
    for(k=1; k<=r; k++)
    {
 
        j=0;
        for(i=1; i<=n; i++)
        {
            totalloc[k]=j+resalloc[i][k];
            j=totalloc[k];
        }
    }
    for(i=1; i<=n; i++)
    {
        if(block[i]==1||run[i]==1)
            active[i]=1;
        else
            active[i]=0;
    }
    for(k=1; k<=r; k++)
    {
        resalloc[p][k]+=newreq[k];
        totalloc[k]+=newreq[k];
    }
    for(k=1; k<=r; k++)
    {
        if(totext[k]-totalloc[k]<0)
        {
            u=1;
            break;
        }
    }
    if(u==0)
    {
        for(k=1; k<=r; k++)
            simalloc[k]=totalloc[k];
        for(s=1; s<=n; s++)
            for(i=1; i<=n; i++)
            {
                if(active[i]==1)
                {
                    j=0;
                    for(k=1; k<=r; k++)
                    {
                        if((totext[k]-simalloc[k])<(max[i][k]-resalloc[i][k]))
                        {
                            j=1;
                            break;
                        }
                    }
                }
                if(j==0)
 
                {
                    active[i]=0;
                    for(k=1; k<=r; k++)
                        simalloc[k]=resalloc[i][k];
                }
            }
        m=0;
        for(k=1; k<=r; k++)
            resreq[p][k]=newreq[k];
        printf("Deadlock willn't occur");
    }
    else
    {
        for(k=1; k<=r; k++)
        {
            resalloc[p][k]=newreq[k];
            totalloc[k]=newreq[k];
        }
        printf("Deadlock will occur");
    }
    getch();
}

https://www.programming9.com/programs/c-programs/167-simulate-bankers-algorithm-for-deadlock-avoidance-using-c



///////////best for safe sequence

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int Max[10][10], need[10][10], alloc[10][10], avail[10], completed[10], safeSequence[10];
    int p, r, i, j, process, count;
    count = 0;

    printf("Enter the no of processes : ");
    scanf("%d", &p);

    for(i = 0; i< p; i++)
        completed[i] = 0;

    printf("\n\nEnter the no of resources : ");
    scanf("%d", &r);

    printf("\n\nEnter the Max Matrix for each process : ");
    for(i = 0; i < p; i++)
    {
        printf("\nFor process %d : ", i + 1);
        for(j = 0; j < r; j++)
            scanf("%d", &Max[i][j]);
    }

    printf("\n\nEnter the allocation for each process : ");
    for(i = 0; i < p; i++)
    {
        printf("\nFor process %d : ",i + 1);
        for(j = 0; j < r; j++)
            scanf("%d", &alloc[i][j]);
    }

    printf("\n\nEnter the Available Resources : ");
    for(i = 0; i < r; i++)
        scanf("%d", &avail[i]);

    for(i = 0; i < p; i++)

        for(j = 0; j < r; j++)
            need[i][j] = Max[i][j] - alloc[i][j];

        do
        {
            printf("\n Max matrix:\tAllocation matrix:\n");

            for(i = 0; i < p; i++)
            {
                for( j = 0; j < r; j++)
                    printf("%d ", Max[i][j]);
                printf("\t\t");
                for( j = 0; j < r; j++)
                    printf("%d ", alloc[i][j]);
                printf("\n");
            }

            process = -1;

            for(i = 0; i < p; i++)
            {
                if(completed[i] == 0)//if not completed
                {
                    process = i ;
                    for(j = 0; j < r; j++)
                    {
                        if(avail[j] < need[i][j])
                        {
                            process = -1;
                            break;
                        }
                    }
                }
                if(process != -1)
                    break;
            }

            if(process != -1)
            {
                printf("\nProcess %d runs to completion!", process + 1);
                safeSequence[count] = process + 1;
                count++;
                for(j = 0; j < r; j++)
                {
                    avail[j] += alloc[process][j];
                    alloc[process][j] = 0;
                    Max[process][j] = 0;
                    completed[process] = 1;
                }
            }
        }
        while(count != p && process != -1);

        if(count == p)
        {
            printf("\nThe system is in a safe state!!\n");
            printf("Safe Sequence : < ");
            for( i = 0; i < p; i++)
                printf("%d ", safeSequence[i]);
            printf(">\n");
        }
        else
            printf("\nThe system is in an unsafe state!!");

}


////////////////another one for deadlock
#include<stdio.h>
#include<process.h>
#include<conio.h>
void main()
{
int allocation[10][5],max[10][5],need[10][5],available[3],flag[10],sq[10];
int n,r,i,j,k,count,count1=0;

printf("\n Input the number of processes running ( <10 )..");
scanf("%d",&n);
for(i=0;i<10;i++)
    flag[i]=0;
printf("\n Input the number of resources ( <5 )..");
scanf("%d",&r);
printf("\n Input the allocation matrix for the processes in row major order..\n");
for(i=0;i<n;i++)
{
    printf("\n Process %d\n",i);
    for(j=0;j<r;j++)
    {
        printf("\n Resource %d\n",j);
        scanf("%d",&allocation[i][j]);
    }
}
printf("\n Input the no. of resources that a process can maximum have..\n");
for(i=0;i<n;i++)
{
    printf("\n Process %d\n",i);
    for(j=0;j<r;j++)
    {
        printf("\n Resource %d\n",j);
        scanf("%d",&max[i][j]);
    }
}
printf("\n Input the no. of available instances of each resource..\n");
for(i=0;i<r;i++)
{
    printf("\n Resource %d : ",i);
    scanf("%d",&available[i]);
}
printf("\n The need matrix is as follows : \n");
for(i=0;i<n;i++)
{
    for(j=0;j<r;j++)
    {
        need[i][j]= max[i][j]-allocation[i][j];
        printf("\t %d",need[i][j]);
    }
    printf("\n");
}
do{
  for(k=0;k<n;k++)
  {
      for(i=0;i<n;i++)
      {
          if(flag[i]==0)
          {
            count=0;
            for(j=0;j<r;j++)
            {
               if(available[j]>=need[i][j])
               count++;
            }
            if(count==r)
            {
               count1++;
               flag[i]=1;
               sq[count1-1]=i;
               for(j=0;j<r;j++)
              {
                   available[j]=available[j]+allocation[i][j];
              }
               break;
            }
         }
     }
  }
  if(count1!=n)
  {
     printf("\n---------------IT'S AN UNSAFE STATE---------------");
     break;
  }
}while(count1!=n);
if(count1==n)
{
   printf("\n *******************IT'S A SAFE STATE*******************");
   printf("\n The safe sequence is....\n");
   for(i=0;i<n;i++)
       printf("\t P%d",sq[i]);
   printf("\n");
   printf("\n The available matrix is now : ");
   for(i=0;i<r;i++)
       printf("\t %d",available[i]);
}
getch();
}

///////another for bankers
#include <stdio.h>
int curr[5][5], maxclaim[5][5], avl[5];
int alloc[5] = {0, 0, 0, 0, 0};
int maxres[5], running[5], safe=0;
int count = 0, i, j, exec, r, p, k = 1;

int main()
{
    printf("\nEnter the number of processes: ");
    scanf("%d", &p);

    for (i = 0; i < p; i++) {
        running[i] = 1;
        count++;
    }

    printf("\nEnter the number of resources: ");
    scanf("%d", &r);

    for (i = 0; i < r; i++) {
        printf("\nEnter the resource for instance %d: ", k++);
        scanf("%d", &maxres[i]);
    }

    printf("\nEnter maximum resource table:\n");
    for (i = 0; i < p; i++) {
        for(j = 0; j < r; j++) {
            scanf("%d", &maxclaim[i][j]);
        }
    }

    printf("\nEnter allocated resource table:\n");
    for (i = 0; i < p; i++) {
        for(j = 0; j < r; j++) {
            scanf("%d", &curr[i][j]);
        }
    }

    printf("\nThe resource of instances: ");
    for (i = 0; i < r; i++) {
        printf("\t%d", maxres[i]);
    }

    printf("\nThe allocated resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            printf("\t%d", curr[i][j]);
        }

        printf("\n");
    }

    printf("\nThe maximum resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            printf("\t%d", maxclaim[i][j]);
        }

        printf("\n");
    }

    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            alloc[j] += curr[i][j];
        }
    }

    printf("\nAllocated resources:");
    for (i = 0; i < r; i++) {
        printf("\t%d", alloc[i]);
    }

    for (i = 0; i < r; i++) {
        avl[i] = maxres[i] - alloc[i];
    }

    printf("\nAvailable resources:");
    for (i = 0; i < r; i++) {
        printf("\t%d", avl[i]);
    }
    printf("\n");

    //Main procedure goes below to check for unsafe state.
    while (count != 0) {
        safe = 0;
        for (i = 0; i < p; i++) {
            if (running[i]) {
                exec = 1;
                for (j = 0; j < r; j++) {
                    if (maxclaim[i][j] - curr[i][j] > avl[j]) {
                        exec = 0;
                        break;
                    }
                }
                if (exec) {
                    printf("\nProcess%d is executing\n", i + 1);
                    running[i] = 0;
                    count--;
                    safe = 1;

                    for (j = 0; j < r; j++) {
                        avl[j] += curr[i][j];
                    }

                    break;
                }
            }
        }
        if (!safe) {
            printf("\nThe processes are in unsafe state.\n");
            break;
        } else {
            printf("\nThe process is in safe state");
            printf("\nSafe sequence is:");

            for (i = 0; i < r; i++) {
                printf("\t%d", avl[i]);
            }

            printf("\n");
        }
    }
}


////bankers
#include<stdio.h>
 #include<conio.h>

void main()
{
  int process,resource,i,j,instanc,k=0,count1=0,count2=0; //count,k      variables are taken for counting purpose
  printf("\n\t Enter No. of Process:-\n");
  printf("\t\t");
  scanf("%d",&process);                            //Entering No. of Processes
  printf("\n\tEnter No. of Resources:-\n");
  printf("\t\t");
  scanf("%d",&resource);                       //No. of Resources

  int avail[resource],max[process][resource],allot[process][resource],need[process][resource],completed[process];

  for(i=0;i<process;i++)
  completed[i]=0;                             //Setting Flag for uncompleted Process

  printf("\n\tEnter No. of Available Instances\n");

  for(i=0;i<resource;i++)
  {
    printf("\t\t");
    scanf("%d",&instanc);
    avail[i]=instanc;                        // Storing Available instances
  }

  printf("\n\tEnter Maximum No. of instances of resources that a Process need:\n");

  for(i=0;i<process;i++)
  {
    printf("\n\t For P[%d]",i);
    for(j=0;j<resource;j++)
     {
        printf("\t");
        scanf("%d",&instanc);
        max[i][j]=instanc;
     }
  }
  printf("\n\t Enter no. of instances already allocated to process of a resource:\n");

  for(i=0;i<process;i++)
  {
    printf("\n\t For P[%d]\t",i);
    for(j=0;j<resource;j++)
     {
        printf("\t\t");
        scanf("%d",&instanc);
        allot[i][j]=instanc;
        need[i][j]=max[i][j]-allot[i][j];       //calculating Need of each process
     }
 }
printf("\n\t Safe Sequence is:- \t");

 while(count1!=process)
 {
  count2=count1;
  for(i=0;i<process;i++)
  {
    for(j=0;j<resource;j++)
    {
        if(need[i][j]<=avail[j])
          {
            k++;
          }
    }
    if(k==resource && completed[i]==0 )
     {
       printf("P[%d]\t",i);
       completed[i]=1;
       for(j=0;j<resource;j++)
         {
           avail[j]=avail[j]+allot[i][j];
          }
         count1++;
     }
     k=0;
   }

     if(count1==count2)
     {
     printf("\t\t Stop ..After this.....Deadlock \n");
     break;
   }
 }
 getch();
}


///////////////////////////////////////////////
#include<stdio.h>
#include<conio.h>
int main()
{
int clm[7][5],req[7][5],alloc[7][5],rsrc[5],avail[5],comp[7];
int first,p,r,i,j,prc,count,t;
count=0;
for(i=1;i<=7;i++)
comp[i]=0;
printf("----------------------------------------------------\n");
printf("-------------Made by C codechamp--------------------\n");
printf("----------------------------------------------------\n\n");
printf("\t BANKERS ALGORITHM IN C \n\n");
printf("Enter the no of processes : ");
scanf("%d",&p);
printf("\n\nEnter the no of resources : ");
scanf("%d",&r);
printf("\n\nEnter the claim for each process : ");
for(i=1;i<=p;i++)
{
printf("\nFor process %d : ",i);
for(j=1;j<=r;j++)
{
scanf("%d",&clm[i][j]);
}
}
printf("\n\nEnter the allocation for each process : ");
for(i=1;i<=p;i++)
{
printf("\nFor process %d : ",i);
for(j=1;j<=r;j++)
{
scanf("%d",&alloc[i][j]);
}
}
printf("\n\nEnter total no of each resource : ");
for(j=1;j<=r;j++)
scanf("%d",&rsrc[j]);
for(j=1;j<=r;j++)
{
int total=0;
avail[j]=0;
for(i=1;i<=p;i++)
{total+=alloc[i][j];}
avail[j]=rsrc[j]-total;
}
do
{
for(i=1;i<=p;i++)
{
for(j=1;j<=r;j++)
{
req[i][j]=clm[i][j]-alloc[i][j];
}
}
printf("\n\nAvailable resources are : ");
for(j=1;j<=r;j++)
{ printf(" ",avail[j]); }
printf("\nClaim matrix:\tAllocation matrix:\n");
for(i=1;i<=p;i++)
{
for(j=1;j<=r;j++)
{
printf("%d\t",clm[i][j]);
}
printf("\t\t\t");
for(j=1;j<=r;j++)
{
printf("%d\t",alloc[i][j]);
}
printf("\n");
}
prc=0;
for(i=1;i<=p;i++)
{
if(comp[i]==0)//if not completed
{
prc=i;
for(j=1;j<=r;j++)
{
if(avail[j]=0)
{
prc=0;
break;
}
}
}
if(prc!=0)
break;
}
if(prc!=0)
{
printf("\nProcess ",prc,"runs to completion!");
count++;
for(j=1;j<=r;j++)
{
avail[j]+=alloc[prc][j];
alloc[prc][j]=0;
clm[prc][j]=0;
comp[prc]=1;
}
}
}
while(count!=p&&prc!=0);
if(count==p)
printf("\nThe system is in a safe state!!");
else
printf("\nThe system is in an unsafe state!!");
getch();
}

//////scheduling algorithms

///ffcs
ALGORITHM
Step1: START.
Step2: Create three arrays, i.e. the waiting time, burst time and the turnaround time respectively.
Step3: Ask the user for the number of processes.
Step4: Read the value of the burst time for all the processes and store in the burst time array.
Step5: Declare the initial value of waiting time as 0 for process 1.

Step6: Define the waiting time array as waiting time=waiting time+burst time for every loop, and run it till the end.
Step7: Define the turnaround time as turnaround time=waiting time+burst time.
Step8: Calculate the average waiting time and turnaround time.
Step9: Display the result on the screen.
Step10: Display the average waiting time and turnaround time on the screen.
Step11: END

code :


#include<stdio.h>
int main()
{
    int n=0;
    int burst_time[30];
    int waiting_time[30];
    int turnaround_time[30];
    int average_waiting_time=0;
    int average_turnaround_time=0;
    int i=0;
    int j=0;
    
    printf("PART ONE:\n");
    printf("FCFS SCHEDULING ALGORITHM\n");
    
    //Asking for the total number of processes
    printf("Enter the number of processes to be executed:");
    scanf("%d",&n);
    
    //Asking the user for the individual burst times
    printf("\nEnter the Burst Time of each process:\n\n");
    
    for(i=0;i<n;i++)
    {
        printf("Process %d:",i+1);
        scanf("%d",&burst_time[i]);
    }
    
    //Declaring the Waiting time of the Initial process as 0
    waiting_time[0]=0;
    
    //calculating waiting time of each process
    for(i=1;i<n;i++)
    {
        waiting_time[i]=0;
        for(j=0;j<i;j++)
            waiting_time[i]+=burst_time[j];
    }
    
    printf("\nRESULT: \n");
    printf("\nProcess\t\tBurst Time\t\tWaiting Time\tTurnaround Time\n");
    printf("----------------------------------------------------------");
    
    //calculating turnaround time of each process
    for(i=0;i<n;i++)
    {
        turnaround_time[i]=burst_time[i]+waiting_time[i];
        average_waiting_time=average_waiting_time+waiting_time[i];
        average_turnaround_time=average_turnaround_time+turnaround_time[i];
        printf("\nProcess %d\t\t%d\t\t\t\t%d\t\t\t\t%d",i+1,burst_time[i],waiting_time[i],turnaround_time[i]);
    }
    
    average_waiting_time/=i;
    average_turnaround_time/=i;
    printf("\n\nThe Average Waiting Time is:%d",average_waiting_time);
    printf("\n\nThe Average Turnaround Time is:%d\n\n",average_turnaround_time);
    
    return 0;
}
//////////////////////or 
#include<stdio.h> 
  
int main() { 
    int n,bt[20],wt[20],tat[20],avwt=0,avtat=0,i,j;   
  printf("Enter total number of processes(maximum 20):");
    scanf("%d",&n); 
  
    printf("\nEnter Process Burst Time\n"); 
    for(i=0;i<n;i++) 
    { 
        printf("P[%d]:",i+1);         scanf("%d",&bt[i]); 
    } 
  
    wt[0]=0;    //waiting time for first process is 0 
  
    //calculating waiting time     for(i=1;i<n;i++) 
    {         wt[i]=0;         for(j=0;j<i;j++)             wt[i]+=bt[j]; 
    } 
  
    printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time");   
    //calculating turnaround time 
    for(i=0;i<n;i++) 
    { 
        tat[i]=bt[i]+wt[i];         avwt+=wt[i]; 
        avtat+=tat[i]; 
        printf("\nP[%d]\t\t%d\t\t%d\t\t%d",i+1,bt[i],wt[i],tat[i]); 
    } 
  
    avwt/=i; 
    avtat/=i; 
    printf("\n\nAverage Waiting Time:%d",avwt);     printf("\nAverage Turnaround Time:%d",avtat); 
  
    return 0; 
} 


/////////////////////sjf:

C CODE
#include<stdio.h>
int main()
{
    int i=0;
    int j=0;
    int n=0;
    int total=0;
    int position=0;
    int temp=0;
    int burst_time[30];
    int temporary[30];
    int waiting_time[30];
    int turnaround_time[30];
    float average_waitng_time=0;
    float average_turnaround_time=0;
    
    printf("PART TWO:\n");
    printf("SJF SCHEDULING ALGORITHM\n");
    
    //Requesting for the number of processes
    printf("Enter the number of process:");
    scanf("%d",&n);
    
    //Reading the burst times
    printf("\nEnter Burst Time of each process:\n");
    for(i=0;i<n;i++)
    {
        printf("process %d:",i+1);
        scanf("%d",&burst_time[i]);
        temporary[i]=i+1;
    }
    
    //Using selection  sort to sort burst times
    for(i=0;i<n;i++)
    {
        position=i;
        for(j=i+1;j<n;j++)
        {
            if(burst_time[j]<burst_time[position])
                position=j;
        }
        
        temp=burst_time[i];
        burst_time[i]=burst_time[position];
        burst_time[position]=temp;
        
        temp=temporary[i];
        temporary[i]=temporary[position];
        temporary[position]=temp;
    }
    
    //Declaring the waiting time for the first process as 0
    waiting_time[0]=0;
    
    //calculate waiting time
    for(i=1;i<n;i++)
    {
        waiting_time[i]=0;
        for(j=0;j<i;j++)
            waiting_time[i]=waiting_time[i]+burst_time[j];
        
        total=total+waiting_time[i];
    }
    
    //Calculating average waiting time
    average_waitng_time=(float)total/n;
    total=0;
    
    printf("\nRESULT: \n");
    printf("\nProcess\t    Burst Time    \tWaiting Time\tTurnaround Time");
    for(i=0;i<n;i++)
    {
        turnaround_time[i]=burst_time[i]+waiting_time[i];     //calculate turnaround time
        total+=turnaround_time[i];
        printf("\np%d\t\t\t  %d\t\t\t\t    %d\t\t\t\t%d",temporary[i],burst_time[i],waiting_time[i],turnaround_time[i]);
    }
    
    //Calculating average turnaround time
    average_turnaround_time=(float)total/n;
    printf("\n\nThe Average Waiting Time is: %f\n",average_waitng_time);
    printf("\nThe Average Turnaround Time is: %f\n\n",average_turnaround_time);
}


0r

#include<stdio.h>
void main() {
    int bt[20],p[20],wt[20],tat[20],i,j,n,total=0,pos,temp;
        float avg_wt,avg_tat;
         printf("Enter number of process:");
          scanf("%d",&n);

    printf("\nEnter Burst Time:\n");
    for(i=0;i<n;i++)
    {
        printf("p%d:",i+1);
        scanf("%d",&bt[i]);
        p[i]=i+1;           //contains process number
    }

    //sorting burst time in ascending order using selection sort     for(i=0;i<n;i++)
    {         pos=i;
     for(j=i+1;j<n;j++)
        {
            if(bt[j]<bt[pos])
                        pos=j;
        }

        temp=bt[i];
                bt[i]=bt[pos];

       bt[pos]=temp;

        temp=p[i];
        p[i]=p[pos];
        p[pos]=temp;
    }

    wt[0]=0;            //waiting time for first process will be zero

    //calculate waiting time     for(i=1;i<n;i++)
    {         wt[i]=0;
     for(j=0;j<i;j++)
            wt[i]+=bt[j];

        total+=wt[i];
    }

    avg_wt=(float)total/n;      //average waiting time     total=0;

    printf("\nProcess\t    Burst Time    \tWaiting Time\tTurnaround Time");
     for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];     //calculate turnaround time         total+=tat[i];
        printf("\np%d\t\t  %d\t\t    %d\t\t\t%d",p[i],bt[i],wt[i],tat[i]);
    }

    avg_tat=(float)total/n;     //average turnaround time     printf("\n\nAverage Waiting Time=%f",avg_wt);
    printf("\nAverage Turnaround Time=%f\n",avg_tat);
}


////////////////////priority scheduling algorithm


ALGORITHM
Step1: START.
Step2: Create five arrays, i.e. the waiting time, burst time, temporary array, priority and the turnaround time respectively.
Step3: Ask the user for the number of processes.
Step4: Read the value of the burst time and priority for all the processes and store in the burst time array and the priority array respectively.
Step5: Declare the initial value of waiting time as 0 for process 1.
Step6: Use Selection sort to sort the priority array in ascending order, and hence simultaneously sort the burst time and arrival time as well. 
     Step7: Calculate the waiting time of each job using the equation waiting_time[i]+=burst_time[j];
Step8: Calculate the turnaround time for each process.
Step9: Calculate the average waiting time and turnaround time.
Step10: Display the result on the screen.
Step11: Display the average waiting time and turnaround time on the screen.
Step12: END
C CODE


#include<stdio.h>
int main()
{
    int i=0;
    int j=0;
    int n=0;
    int total=0;
    int position=0;
    int temp=0;
    int burst_time[30];
    int temporary[30];
    int waiting_time[30];
    int turnaround_time[30];
    int priority[30];
    float average_waiting_time=0;
    float average_turnaround_time=0;
    
    printf("PART THREE:\n");
    printf("PRIORITY SCHEDULING ALGORITHM\n");
    
    //Requesting for the number of processes
    printf("Enter Total Number of Processes:");
    scanf("%d",&n);
    
    printf("\nEnter the Burst Times and Priority for the respective Processes\n");
    for(i=0;i<n;i++)
    {
        printf("\nProcess %d\n",i+1);
        printf("Burst Time:");
        scanf("%d",&burst_time[i]);
        printf("Priority:");
        scanf("%d",&priority[i]);
        temporary[i]=i+1;
    }
    
    //sorting burst time, priority and process number in ascending order using selection sort
    for(i=0;i<n;i++)
    {
        position=i;
        for(j=i+1;j<n;j++)
        {
            if(priority[j]<priority[position])
                position=j;
        }
        
        temp=priority[i];
        priority[i]=priority[position];
        priority[position]=temp;
        
        temp=burst_time[i];
        burst_time[i]=burst_time[position];
        burst_time[position]=temp;
        
        temp=temporary[i];
        temporary[i]=temporary[position];
        temporary[position]=temp;
    }
    
    //Declaring waiting time for first process as 0
    waiting_time[0]=0;
    
    //calculate waiting time for the jobs
    for(i=1;i<n;i++)
    {
        waiting_time[i]=0;
        for(j=0;j<i;j++)
            waiting_time[i]+=burst_time[j];
        
        total=total+waiting_time[i];
    }
    
    //Calculating average waiting time
    average_waiting_time=(float)total/n;
    total=0;
    
    printf("\nProcess\t    Burst Time    \tWaiting Time\tTurnaround Time");
    for(i=0;i<n;i++)
    {
        //Calculating turnaround time
        turnaround_time[i]=burst_time[i]+waiting_time[i];
        total=total+turnaround_time[i];
        printf("\nProcess %d\t\t  %d\t\t\t    %d\t\t\t\t%d",temporary[i],burst_time[i],waiting_time[i],turnaround_time[i]);
    }
    
    //Calculating average turnaround time
    average_turnaround_time=(float)total/n;
    printf("\n\nThe Average Waiting Time is: %f\n",average_waiting_time);
    printf("\nThe Average Turnaround Time is: %f\n\n",average_turnaround_time);
    
    return 0;
}





 

///////////////////////
4. Round Robin Scheduling Algorithm
ALGORITHM
Step1: START.
Step2: Create five arrays, i.e. the waiting time, burst time, temporary array,  and the turnaround time respectively.
Step3: Ask the user for the number of processes.
Step4: Read the value of the burst time and arrival time for all the processes and store in the burst time array and the arrival time array respectively.
Step5: Declare the initial value of waiting time as 0 for process 1.
Step6: Read the value of Quantum time.
Step7: For each job, look if the assigned time is less than the quantum time or not. If it is less, then terminate the job on the spot. Else, deduct the quantum time from the remaining time and head on to the next process.
Step8: Continue till the remaining time of all the jobs reach zero.
Step9: Add the respective waiting times for each job and thus calculate the turnaround time too.
Step10: Calculate the average waiting time.
Step11: Calculate the average turnaround time.
Step12: Display the average waiting and turnaround time for the processes.
Step13: END.
C CODE
#include<stdio.h>
int main()
{
    
    int i=0;
    int n=0;
    int time=0;
    int remain=0;
    int flag=0;
    int quantum_time=0;
    int waiting_time=0;
    int turnaround_time=0;
    int arrival_time[30];
    int burst_time[30];
    int remaining_time[30];
    
    printf("PART FOUR:\n");
    printf("ROUND ROBIN SCHEDULING ALGORITHM\n\n");
    
    //Requesting for the number of processes
    printf("Enter Total Number of Processes:");
    scanf("%d",&n);
    
    remain=n;
    
    //Requesting for the number of processes
    for(i=0;i<n;i++)
    {
        printf("\nProcess %d\n",i+1);
        printf("Enter Arrival Time:");
        scanf("%d",&arrival_time[i]);
        printf("Enter Burst Time: ");
        scanf("%d",&burst_time[i]);
        remaining_time[i]=burst_time[i];
    }
    
    //Requesting the Quantum time
    printf("\nEnter Time Quantum:\t");
    scanf("%d",&quantum_time);
    printf("\n\nProcess\t    Turnaround Time     Waiting Time\n\n");
    for(time=0,i=0;remain!=0;)
    {
        if(remaining_time[i]<=quantum_time && remaining_time[i]>0)
        {
            time+=remaining_time[i];
            remaining_time[i]=0;
            flag=1;
        }
        else if(remaining_time[i]>0)
        {
            remaining_time[i]-=quantum_time;
            time+=quantum_time;
        }
        if(remaining_time[i]==0 && flag==1)
        {
            remain--;
            printf("Process %d   \t\t%d\t\t\t\t%d\n",i+1,time-arrival_time[i],time-arrival_time[i]-burst_time[i]);
            waiting_time+=time-arrival_time[i]-burst_time[i];
            turnaround_time+=time-arrival_time[i];
            flag=0;
        }


/////////////pre-emptive priority

5. Pre-emptive Priority 

Step1: START.
Step2: Declare 6 arrays for the burst time, arrival time, remaining time, priority, turnaround time and temporary respectively.
Step3: Ask the user for the number of processes and store it in n.
Step4: Ask the user for the arrival time of each process and store it in arrival_time.
Step5: Ask the user for the burst times of each process and store it in burst_time.
Step6: Ask the user for the priority of each process and store it in the priority array.
Step7: Using sorting algorithm, sort the priority array, andhence simultaneously sort the remaining arrays.
Step8: Search for the element with the smallest value in the arrival time.That becomes the first job to be executed.
Step9: Repeat the steps and calculate the remaining time foreach job after it is executed partially and store the result back in the temporary array.
Step10: Calculate the waiting time for each process and display the result.
Step11: Calculate the turnaround time for each process and display the result.
Step12: Calculate the average waiting time and average turnaround time.
Step13: Display the results on the screen.
Step14: END.

#include<stdio.h>

//Declaring a structure for job
struct job
{
    char job_name;
    int arrival_time;
    int burst_time;
    int ct;
    int waiting_time;
    int turnaround_time;
    int priority;
    int status;
}job_queue[10];

int lim;

//Generating a function for sorting arrival time
void sorting_arrival_time()
{
    struct job temp;
    int i, j;
    for(i=0;i<lim-1;i++)
    {
        for(j=i+1;j<lim;j++)
        {
            if(job_queue[i].arrival_time>job_queue[j].arrival_time)
            {
                temp = job_queue[i];
                job_queue[i] = job_queue[j];
                job_queue[j] = temp;
            }
        }
    }
}

int main()
{
    int i=0;
    int time=0;
    int burst_time=0;
    int largest;
    char c;
    float wait_time = 0;
    int turnaround_time = 0;
    float average_waiting_time;
    float average_turnaround_time;
    
    printf("PART FIVE:\n");
    printf("PREEMPTIVE PRIORITY SCHEDULING ALGORITHM\n\n");
    
    printf("\nEnter the Number of Processes to be executed:\t");
    scanf("%d", &lim);
    
    //Reading the details of burst time and arrival time from the user
    for(i=0,c='A';i<lim;i++,c++)
    {
        job_queue[i].job_name=c;
        printf("\nProcess %C:\n", job_queue[i].job_name);
        
        printf("Enter Arrival Time:\t");
        scanf("%d", &job_queue[i].arrival_time );
        
        printf("Enter Burst Time:\t");
        scanf("%d", &job_queue[i].burst_time);
        
        printf("Enter Priority:\t");
        scanf("%d", &job_queue[i].priority);
        job_queue[i].status = 0;
        burst_time = burst_time + job_queue[i].burst_time;
    }
    
    sorting_arrival_time();
    
    job_queue[9].priority = -9999;
    
    //Displaying the Result
    printf("\nProcess Name\tArrival Time\tBurst Time\tPriority\tWaiting Time");
    for(time=job_queue[0].arrival_time;time<burst_time;)
    {
        largest=9;
        for(i=0;i<lim;i++)
        {
            if(job_queue[i].arrival_time<=time && job_queue[i].status!=1 && job_queue[i].priority>job_queue[largest].priority)
            {
                largest = i;
            }
        }
        time = time + job_queue[largest].burst_time;
        job_queue[largest].ct = time;
        job_queue[largest].waiting_time = job_queue[largest].ct - job_queue[largest].arrival_time - job_queue[largest].burst_time;
        job_queue[largest].turnaround_time = job_queue[largest].ct - job_queue[largest].arrival_time;
        job_queue[largest].status = 1;
        wait_time = wait_time + job_queue[largest].waiting_time;
        turnaround_time = turnaround_time + job_queue[largest].turnaround_time;
        printf("\n%c\t\t%d\t\t%d\t\t%d\t\t%d", job_queue[largest].job_name, job_queue[largest].arrival_time, job_queue[largest].burst_time, job_queue[largest].priority, job_queue[largest].waiting_time);
    }
    average_waiting_time = wait_time / lim;
    average_turnaround_time = turnaround_time / lim;
    printf("\n\nAverage waiting time:\t%f\n", average_waiting_time);
    printf("Average Turnaround Time:\t%f\n", average_turnaround_time);
}

        if(i==n-1)
            i=0;
        else if(arrival_time[i+1]<=time)
            i++;
        else
            i=0;
    }

	//Calculating the Average waiting and turnaround time
    printf("\nThe Average Waiting Time is: %f\n",waiting_time*1.0/n);
    printf("\nThe Average Turnaround Time is: %f\n\n",turnaround_time*1.0/n);
    
    return 0;
}






////////////////srtf


ALGORITHM AND PSEUDO CODE : 
Step1: START. 
Step2: Declare 5 arrays for the burst time, arrival time, remaining time, turnaround time and temporary respectively. 
Step3: Ask the user for the number of processes and store it in n. 
Step4: Ask the user for the arrival time of each process and store it in arrival_time. 
Step5: Ask the user for the burst times of each process and store it in burst_time. 
Step6: Use sorting algorithm to sort the remaining timearray, and hence simultaneously sort the burst timeand arrival time arrays as well. 
Step7: Initiatethe waiting time of the first process as zero. 
Step8: The element in the arrival time with the smallest value becomes the first process to be executed. 
Step9: Using recursive algorithm,extract the processes according to the shortest remaining time in the remaining_time array as soon as the time elapsed becomes equal to the arrival time of any process. 
Step10: Calculate the waiting time of each process and display it on the screen. 
Step11: Calculate the turnaround time for each process and display it on the screen. 
Step12: END.


#include<stdio.h>
int main()
{
    int at[10],bt[10],rt[10],endTime,i,smallest;
    int remain=0,n,time,sum_wait=0,sum_turnaround=0;
    printf("Enter no of Processes : ");
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        printf("Enter arrival time for Process P%d : ",i+1);
        scanf("%d",&at[i]);
        printf("Enter burst time for Process P%d : ",i+1);
        scanf("%d",&bt[i]);
        rt[i]=bt[i];
    }
    printf("\n\nProcess\t|Turnaround Time| Waiting Time\n\n");
    rt[9]=9999;
    for(time=0;remain!=n;time++)
    {
        smallest=9;
        for(i=0;i<n;i++)
        {
            if(at[i]<=time && rt[i]<rt[smallest] && rt[i]>0)
            {
                smallest=i;
            }
        }
        rt[smallest]--;
        if(rt[smallest]==0)
        {
            remain++;
            endTime=time+1;
            printf("\nP[%d]\t|\t%d\t|\t%d",smallest+1,endTime-at[smallest],endTime-bt[smallest]-at[smallest]);
            sum_wait+=endTime-bt[smallest]-at[smallest];
            sum_turnaround+=endTime-at[smallest];
        }
    }
    printf("\n\nAverage waiting time = %f\n",sum_wait*1.0/n);
    printf("Average Turnaround time = %f",sum_turnaround*1.0/5);
    return 0;
}
 


code:
#include <stdio.h>
int main()
{
 int a[10],b[10],x[10],i,j,smallest,count=0,time,n;
 double avg=0,tt=0,end;
  printf("enter the number of Processes:\n");
     scanf("%d",&n);
     printf("enter arrival time\n");
       for(i=0;i<n;i++)
        scanf("%d",&a[i]);
       printf("enter burst time\n");
        for(i=0;i<n;i++)

            scanf("%d",&b[i]);
        for(i=0;i<n;i++)
            x[i]=b[i];

  b[9]=9999;

 for(time=0;count!=n;time++)
 {
   smallest=9;
   for(i=0;i<n;i++)
  {
   if(a[i]<=time && b[i]<b[smallest] && b[i]>0 )
        smallest=i;
  }
  b[smallest]--;
   if(b[smallest]==0)
  {
   count++;
    end=time+1;
      avg=avg+end-a[smallest]-x[smallest];
      tt= tt+end-a[smallest];
  }
 }
 printf("\n\nAverage waiting time = %lf\n",avg/n);
  printf("Average Turnaround time = %lf",tt/n);
   return 0;
}

////////////////////////////////////////////
non preemptive:

#include<stdio.h>
int main()
{
int burst_time[20], process[20], waiting_time[20], turnaround_time[20], priority[20];
int i, j, limit, sum = 0, position, temp;
float average_wait_time, average_turnaround_time;
printf("Enter Total Number of Processes:\t");
scanf("%d", &limit);
printf("\nEnter Burst Time and Priority For %d Processes\n", limit);
for(i = 0; i < limit; i++)
{
printf("\nProcess[%d]\n", i + 1);
printf("Process Burst Time:\t");
scanf("%d", &burst_time[i]);
printf("Process Priority:\t");
scanf("%d", &priority[i]);
process[i] = i + 1;
}
for(i = 0; i < limit; i++)
{
position = i;
for(j = i + 1; j < limit; j++)
{
if(priority[j] < priority[position])
{
position = j;
}
}
temp = priority[i];
priority[i] = priority[position];
priority[position] = temp;
temp = burst_time[i];
burst_time[i] = burst_time[position];
burst_time[position] = temp;
temp = process[i];
process[i] = process[position];
process[position] = temp;
}
waiting_time[0] = 0;
for(i = 1; i < limit; i++)
{
waiting_time[i] = 0;
for(j = 0; j < i; j++)
{
waiting_time[i] = waiting_time[i] + burst_time[j];
}
sum = sum + waiting_time[i];
}
average_wait_time = sum / limit;
sum = 0;
printf("\nProcess ID\t\tBurst Time\t Waiting Time\t Turnaround Time\n");
for(i = 0; i < limit; i++)
{
turnaround_time[i] = burst_time[i] + waiting_time[i];
sum = sum + turnaround_time[i];
printf("\nProcess[%d]\t\t%d\t\t %d\t\t %d\n", process[i], burst_time[i], waiting_time[i], turnaround_time[i]);
}
average_turnaround_time = sum / limit;
printf("\nAverage Waiting Time:\t%f", average_wait_time);
printf("\nAverage Turnaround Time:\t%f\n", average_turnaround_time);
return 0;
}



///////////////////////


//////////////////Menu driven program to perform basic arithmetic operations. (Hint: Get corresponding operators and values as input)

Solution)

Algorithm for the question:
 
Step1: 
Step 1: START.
Step 2: Display the menu on the screen.
Step 3: Take input m.
Step 4: Ask the user for two numbers and scan them.
Step 5: if m=1, then call the function add. If m=2, then call the function sub. If m=3, call the function mul. If m=4, call the function div.
Step 6: Display the result
Step 7:END

CODE:

#include<stdio.h>

int add(int x, int y);
int sub(int x, int y);
int mul(int x, int y);
int div(int x, int y);
void menu();
int main()
{
menu();
return 0;
}
void menu()
{
     int m,x,y;
     printf("\n\nMENU\n");
     printf(“Select the Operation you wish to perform”);
     printf("1. Add\n2. Subract\n3. Multiply\n4. Divide\n5. Exit\n\nEnter your choice : ");
     scanf("%d",&m);
     if(m==1)
     {
              printf("\n\nEnter the two numbers : ");
              scanf("%d%d", &x,&y);
              printf("\nThe Sum is : ");
              printf("%d",add(x,y));
              menu();
     }
     if(m==2)
     {
              printf("\n\nEnter the two numbers : ");
              scanf("%d%d", &x,&y);
 printf(“The Difference is: “);
              printf("%d",sub(x,y));
              menu();
     }
     if(m==3)
     {
              printf("\n\nEnter the two numbers : ");
              scanf("%d%d", &x,&y);
	 printf(“The Multiplication is: “);
              printf("%d",mul(x,y));
              menu();
     }
     if(m==4)
     {
              printf("\n\nEnter the two numbers : ");
              scanf("%d%d", &x,&y);
	printf(“The division is: “);
              printf("%d",div(x,y));
              menu();
     }
     else if(m==5)
     {
          Printf(“Enter a valid Input.”);
     }
}     

int add(int x, int y)
{
    return x+y;
}

int sub(int x, int y)
{
    return x-y;
}

int mul(int x, int y)
{
    return x*y;
}

int div(int x, int y)
{
    return x/y;
}
 
IMPLEMENTATION:

OUTPUT:

///////////////////////////////////////Q.2. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

Step 1: BEGIN
Step 2: Display the Menu on the screen.
Step 3: Ask the user whether to go with swap or without swap.
Step 4: Call the corresponding function.
Step 5: If input is 1, ask the user to enter three numbers.
Step 6: Create two functions with() and without().
Step 7: Call the respective function.
Step 8: Display the swapped values.
Step 9: Display Menu again.
Step 10:END 

CODE:

#include<stdio.h>

int a,b,c,temp,i,j;

void menu();
void with();
void nwith();

int main()
{
    menu();
    return 0;
}

void menu()
{
     int ch;
     printf("\n\nMENU\n");
     printf("1. Enter elements\n2. Swap with variable\n3. Swap without variable\n4. Exit\n\nEnter your choice : ");
     scanf("%d",&ch);
     if(ch==1)
     {
              printf("Enter the three elements : ");
              scanf("%d%d%d", &a, &b, &c);
              printf("\nElements saved\n");
              menu();
    }
     else if(ch==2)
     {
              with();
              menu();
     }
     else if(ch==3)
     {
          nwith();
          menu();
     }
     else
         printf("\nBYE\n");
}

void with()
{
     temp=c;
     c=b;
     b=a;
     a=temp;
     printf("\nSwaped variables are : ");
     printf("%d %d %d", a,b,c);
     
}
void nwith()
{
     c+=a+b;
     a=c-a-b;
     b=c-b-a;
     c=c-a-b;
      printf("\nSwaped variables are : ");
     printf("%d %d %d", a,b,c);
}

IMPLEMENTATION:

OUTPUT:

//////////////////////////////////Q.3. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

Step 1: BEGIN
Step 2: Input number of elements
Step 3: Input all the elements
Step 4: Display Menu(sort or search) 
Step 6: For function sort()
loop i=0 to n-1
loop j=0 to n-i-1 
if(a[j]>a[j+1]);
 Put temp=a[j];
 Put a[j]=a[j+1];
Put a[j+1]=temp;
Print the sorted data
Step 7: For function search()
Input data to be searched
Check the required condition
if not sorted then goto function lsearch()
Input data to be searched
loop from i=0 to n
Step 8: Display Menu
Step 9: Goto step 4 until choice=3
Step 10:END 

CODE:

#include<stdio.h>

int issort=0, a[100], n;

void sort();
void bsearch();
void lsearch();
void menu();

int main()
{
    int i;
    printf("Enter the number of elements : ");
    scanf("%d", &n);
    for(i=0; i<n; i++)
             scanf("%d", &a[i]);
    menu();
    return 0;
}

void menu()
{
     int ch,a,b;
     printf("\n\nMENU\n");
     printf("1. Sort\n2. Search\n3. Exit\n\nEnter your choice : ");
     scanf("%d",&ch);
     if(ch==1)
     {
              issort=1;
              sort();
              menu();
     }
     else if(ch==2 && issort)
     {
          bsearch();
          menu();
     }
     else if(ch==2 && !issort)
    {
          lsearch();
          menu();
     }
     else
         printf(“\nBYE\n”);
}
 

void bsearch()
{
     int temp;
     printf("\n\nEnter the element to be searched : ");
    scanf("%d", &temp);
     int l=0, h=n-1, m, flag=0;
    while(l<=h)
    {
               m=(l+h)/2;
               if(a[m]==temp)
               {
                             flag=1;
                             break;
               }
               else if(a[m]<temp)
                    l=m+1;
               else
                   h=m-1;
    }
    if(flag)
    {
            printf("\nThe element is present!");
    }
    else
        printf("\nElement not found!");
    menu();
}

void lsearch()
{
     int temp, i, flag=0;
     printf("\n\nEnter the element to be searched : ");
    scanf("%d", &temp);
    for(i=0; i<n; i++)
             if(temp==a[i])
                           flag=1;
    if(flag)
    {
            printf("\nThe element is present!");
    }
    else
        printf("\nElement not found!");
    menu();
                           
}

void sort()
{
     int i,j,temp;
     for(i=0; i<n-1; i++)
             for(j=0; j<n-i-1; j++)
                      if(a[j]>a[j+1])
                      {
                                     temp=a[j];
                                     a[j]=a[j+1];
                                     a[j+1]=temp;
                      }
                                     
    printf("\n\nSorted data is \n");
    for(i=0; i<n; i++)
             printf("%d ",a[i]);
}

IMPLEMENTATION:

OUTPUT:

/////////////////////Q.4. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

1).Read the no of rows and columns of matrix 1;
2).Read the elements of matrix 1.
3.Read the no of rows and columns of matrix 2;
4.Read the elements of matrix 2;
5.If (no of rows and columns of matrix1 == no of rows and column of matrix 2)
6.It can undergo addition and subtraction.
7.If the above valid and the condition (no of columns of matrix1 == no of rows of matrix 2)
8.It can undergo multiplication as well.
condition i< total col of matrix1 
condition i< total row of matrix2
9.all the required Functions.
           int i,j;
           printf("\n\n");
           for(i=0;i<3;i++)
           {
               for(j=0;j<3;j++)
                   printf("%d  ",m[i][j]);
               printf("\n");
           }

10.Print the result.
STOP


CODE:

# include<stdio.h>
       void display(int [][3]);
       void main()
       {
           int c;
           void func1();
           void func2();
           void func3();
             
printf("\n- : Matrix Manipulation Functions (for 3 X 3 Matrix) : -");
           printf("\n-------------------------------------");
           printf("\n Matrix Addition            : 1");
           printf("\n Matrix Subtraction         : 2");
           printf("\n Matrix Multiplication      : 3");
           
           printf("\n Enter Your Choice          : ");
           scanf("%d",&c);
           switch(c)
           {
               case 1:
                   func1();
                   break;
               case 2:
                   func2();
                   break;
               case 3:
                   func3();
                   break;
               default:
                   printf("\nInvalid Choice");
           }
           getch();
       }




       void func1()
       {
           int x[3][3],y[3][3],z[3][3];
           void getmatrix(int [][3]);
           void addition(int [][3],int [][3],int [][3]);
           clrscr();
           getmatrix(x);
           getmatrix(y);
           addition(x,y,z);
           printf("\n - : Matrix 1: - \n");
           display(x);
           printf("\n - : Matrix 2: - \n");
           display(y);
           printf("\n - : Matrix Addition (Result): - \n");
           display(z);
       }
       void getmatrix(int t[][3])
       {
           int i,j;
           for(i=0;i<3;i++)
           {
               for(j=0;j<3;j++)
               {
                   printf("Enter element [%d][%d] : ",i,j);
                   scanf("%d",&t[i][j]);
               }
           }
       }
       void addition(int p[][3],int q[][3],int r[][3])
       {     int i,j;
           for(i=0;i<3;i++)
           {      for(j=0;j<3;j++)
                   r[i][j]=p[i][j]+q[i][j];
           }
       }
       void func2()
       {
           int x[3][3],y[3][3],z[3][3];
           void getmatrix(int [][3]);
           void subtraction(int [][3],int [][3],int [][3]);
           clrscr();
           getmatrix(x);
           getmatrix(y);
           subtraction(x,y,z);
           printf("\n - : Matrix 1: - \n");
           display(x);
           printf("\n - : Matrix 2: - \n");
           display(y);
           printf("\n - : Matrix Subtraction (Result): - \n");
           display(z);
       }
       void subtraction(int p[3][3],int q[3][3],int r[3][3])
       {
           int i,j;
           for(i=0;i<3;i++)
           {
               for(j=0;j<3;j++)
                   r[i][j]=p[i][j]-q[i][j];
           }
       }
       void func3()
       {
           int x[3][3],y[3][3],z[3][3];
           void getmatrix(int [][3]);
           void multiplication(int [][3],int [][3],int [][3]);
           clrscr();
           getmatrix(x);
           getmatrix(y);
           multiplication(x,y,z);
           printf("\n - : Matrix 1: - \n");
           display(x);
           printf("\n - : Matrix 2: - \n");
           display(y);
           printf("\n - : Matrix Multiplication (Result): - \n");
           display(z);
       }
       void multiplication(int p[][3],int q[3][3],int r[3][3])
       {
           int i,j,k;
           for(i=0;i<3;i++)                 
//condition i< total row of matrix1
           {
               for(j=0;j<3;j++)         
//condition i< total col of matrix1 or//condition i< total row of matrix2
{
                   r[i][j]=0;
                   for(k=0;k<3;k++) //condition i< total col of matrix2
                       r[i][j]=r[i][j]+(p[i][j]*q[j][k]);
               }
           }
       }
       void display(int m[][3])
       {
           int i,j;
           printf("\n\n");
           for(i=0;i<3;i++)
           {
               for(j=0;j<3;j++)
                   printf("%d  ",m[i][j]);
               printf("\n");
           }
       }


IMPLEMENTATION:

OUTPUT:

////////////Q.5. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

1).Initialize the condition t1=0 and t2=0
2).using the for loop from i=1 to n
3).next term = sum of consecutive numbers
 printf("%d, ", t1);
        nextTerm = t1 + t2;
        t1 = t2;
        t2 = nextTerm
4)Print the Fibonacci Series
END


CODE:

#include <stdio.h>
int main()
{
    int i, n, t1 = 0, t2 = 1, nextTerm;

    printf("Enter the number of terms: ");
    scanf("%d", &n);

    printf("Fibonacci Series: ");

    for (i = 1; i <= n; ++i)
    {
        printf("%d, ", t1);
        nextTerm = t1 + t2;
        t1 = t2;
        t2 = nextTerm;
    }
    return 0;
}


IMPLEMENTATION:

OUTPUT:

///////////////////////Q.6. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

START
1)Give a input of a number
2)initialize the for loop from c=1 to c<=n
3)fact=fact*c here fact =1 initially
4)Display the output in the form of factorial
END

CODE:

#include <stdio.h>
 
int main()
{
  int c, n, fact = 1;
 
  printf("Enter a number to calculate its factorial\n");
  scanf("%d", &n);
 
  for (c = 1; c <= n; c++)
    fact = fact * c;
 
  printf("Factorial of %d = %d\n", n, fact);
 
  return 0;
}

IMPLEMENTATION:

OUTPUT:

//////////////////////Q.7. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

START
1).Read the number.
2).With the help of loop check if (i%2==0)
3).If it does, it is prime else not.
4).Print the result.
STOP

CODE:

#include<stdio.h>
 
int main()
{
   int n, i = 3, count, c;
 
   printf("Enter the number of prime numbers required\n");
   scanf("%d",&n);
 
   if ( n >= 1 )
   {
      printf("First %d prime numbers are :\n",n);
      printf("2\n");
   }
 
   for ( count = 2 ; count <= n ;  )
   {
      for ( c = 2 ; c <= i - 1 ; c++ )
      {
         if ( i%c == 0 )
            break;
      }
      if ( c == i )
      {
         printf("%d\n", i);
         count++;
      }
      i++;
   }
return 0;
}

IMPLEMENTATION:

OUTPUT:

///////////////////////////Q.8. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

1).Read n;
2).With help of loop
3).Initialize sum= sum+ i ; initially sum=0
4).After the loop stops, print the result.
STOP

CODE:

#include<stdio.h>
int main()
{
  int Number, i, Sum = 0;
  
  printf("\nPlease Enter any Integer Value\n");
  scanf("%d", &Number);
  
  for(i = 1; i <= Number; i++)
  {
     Sum = Sum + i;
  }
  
  printf("Sum of Natural Numbers = %d", Sum);
  return 0;
}

IMPLEMENTATION:

OUTPUT:

////////////////////////Q.9. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

START
   Step 1 Take integer variable Arms
   Step 2 Assign value to the variable
   Step 3 Split all digits of Arms
   Step 4 Find cube-value of each digits
   Step 5 Add all cube-values together
   Step 6 Save the output to Sum variable
   Step 7 If Sum equals to Arms print Armstrong Number
   Step 8 If Sum not equals to Arms print Not Armstrong Number
STOP

CODE:

int main()
{
    int number, originalNumber, remainder, result = 0;

    printf("Enter a three digit integer: ");
    scanf("%d", &number);

    originalNumber = number;

    while (originalNumber != 0)
    {
        remainder = originalNumber%10;
        result += remainder*remainder*remainder;
        originalNumber /= 10;
    }

    if(result == number)
        printf("%d is an Armstrong number.",number);
    else
        printf("%d is not an Armstrong number.",number);

    return 0;
}

IMPLEMENTATION:

OUTPUT:

///////////////////////Q.10. Menu driven program to swap three integers using and without using temp variable.

Solution)

Algorithm for the question:

Algorithm:
START
Step1 Read num.
Step2 Run a loop
Step3 Check if (num=i*i)
Step 4If yes, it is a perfect square else it is not.
Step5 Print the result.
STOP

CODE:

#include <stdio.h>

int main()
{
    int a, n;
    printf("Enter a number: ");
    scanf("%d", &n);
    for(a = 0; a <= n; a++)
    {
        if (n == a * a)
        {
            printf("YES");
            return 0;
        }
    }
    printf("NO");
    return 0;
}

//////////////////////page replacement algo:


 ffcs page replacement with benady anomaly:

#include<stdio.h>
int main()
{
int i,j,n,a[50],frame[10],no1, no2,k,avail,count=0, z1, z2;
            printf("\n ENTER THE NUMBER OF PAGES:\n");
scanf("%d",&n);
            printf("\n ENTER THE PAGE NUMBER :\n");
            for(i=1;i<=n;i++)
            scanf("%d",&a[i]);
            printf("\n ENTER THE NUMBER OF FRAMES for case 1(Lesser Frame Value):");
            scanf("%d",&no1);
            printf("\n ENTER THE NUMBER OF FRAMES for case 2(Greater Frame Value):");
            scanf("%d",&no2);
for(i=0;i<no1;i++)
            frame[i]= -1;
                        j=0;
                        printf("\tref string\t page frames\n");
for(i=1;i<=n;i++)
                        {
                                    printf("%d\t\t",a[i]);
                                    avail=0;
                                    for(k=0;k<no1;k++)
if(frame[k]==a[i])
                                                avail=1;
                                    if (avail==0)
                                    {
                                                frame[j]=a[i];
                                                j=(j+1)%no1;
                                                count++;
                                                for(k=0;k<no1;k++)
                                                printf("%d\t",frame[k]);
}
                                    printf("\n");
}
                        printf("Page Fault Is %d\n\n",count);
                        z1 = count;
for(i=0;i<no2;i++)
            frame[i]= -1;
                        j=0;
                        printf("\tref string\t page frames\n");
for(i=1;i<=n;i++)
                        {
                                    printf("%d\t\t",a[i]);
                                    avail=0;
                                    for(k=0;k<no2;k++)
if(frame[k]==a[i])
                                                avail=1;
                                    if (avail==0)
                                    {
                                                frame[j]=a[i];
                                                j=(j+1)%no2;
                                                count++;
                                                for(k=0;k<no2;k++)
                                                printf("%d\t",frame[k]);
}
                                    printf("\n");
}
                        printf("Page Fault Is %d\n\n",count);
                        z2 = count;
if(z1>z2)
        {
                printf("\nNo. of Page Faults with %d Frames: %d\n",no1, z1);
                printf("\nNo. of Page Faults with %d Frames: %d\n",no2, z2);
                printf("No Belady's Anomaly, Page Fault Number is in accordance with the number of FRAMES.\n\n");
        }
else
        {
                printf("\nNo. of Page Faults with %d Frames: %d\n",no1, z1);
                printf("\nNo. of Page Faults with %d Frames: %d\n",no2, z2);
                printf("\nBELADY's ANOMALY EXISTS! \nNo of PF for 3 Frames<4 Frames!\n\n");
        }
        return 0;

}


////////////all page replacement algo menu driven

#include<stdio.h>
int n,nf;
int in[100];
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter length of page reference sequence:");
    scanf("%d",&n);
    printf("\nEnter the page reference sequence:");
    for(i=0; i<n; i++)
        scanf("%d",&in[i]);
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
 
    }
 
    return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 
}
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
void fifo()
{
    initialize();
    for(i=0; i<n; i++)
    {
        printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
 
            for(k=0; k<nf-1; k++)
                p[k]=p[k+1];
 
            p[k]=in[i];
            pgfaultcnt++;
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
 
        printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
 
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
void lru()
{
    initialize();
 
    int least[50];
    for(i=0; i<n; i++)
    {
 
        printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
 
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i-1; k>=0; k--)
                {
                    if(pg==in[k])
                    {
                        least[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    least[j]=-9999;
            }
            int min=9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(least[j]<min)
                {
                    min=least[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault!");
    }
    dispPgFaultCnt();
}
 
void lfu()
{
    int usedcnt[100];
    int least,repin,sofarcnt=0,bn;
    initialize();
    for(i=0; i<nf; i++)
        usedcnt[i]=0;
 
    for(i=0; i<n; i++)
    {
 
        printf("\n For %d :",in[i]);
        if(isHit(in[i]))
        {
            int hitind=getHitIndex(in[i]);
            usedcnt[hitind]++;
            printf("No page fault!");
        }
        else
        {
            pgfaultcnt++;
            if(bn<nf)
            {
                p[bn]=in[i];
                usedcnt[bn]=usedcnt[bn]+1;
                bn++;
            }
            else
            {
                least=9999;
                for(k=0; k<nf; k++)
                    if(usedcnt[k]<least)
                    {
                        least=usedcnt[k];
                        repin=k;
                    }
                p[repin]=in[i];
                sofarcnt=0;
                for(k=0; k<=i; k++)
                    if(in[i]==in[k])
                        sofarcnt=sofarcnt+1;
                usedcnt[repin]=sofarcnt;
            }
 
            dispPages();
        }
 
    }
    dispPgFaultCnt();
}
 
void secondchance()
{
    int usedbit[50];
    int victimptr=0;
    initialize();
    for(i=0; i<nf; i++)
        usedbit[i]=0;
    for(i=0; i<n; i++)
    {
        printf("\nFor %d:",in[i]);
        if(isHit(in[i]))
        {
            printf("No page fault!");
            int hitindex=getHitIndex(in[i]);
            if(usedbit[hitindex]==0)
                usedbit[hitindex]=1;
        }
        else
        {
            pgfaultcnt++;
            if(usedbit[victimptr]==1)
            {
                do
                {
                    usedbit[victimptr]=0;
                    victimptr++;
                    if(victimptr==nf)
                        victimptr=0;
                }
                while(usedbit[victimptr]!=0);
            }
            if(usedbit[victimptr]==0)
            {
                p[victimptr]=in[i];
                usedbit[victimptr]=1;
                victimptr++;
            }
            dispPages();
 
        }
        if(victimptr==nf)
            victimptr=0;
    }
    dispPgFaultCnt();
}
 
int main()
{
    int choice;
    while(1)
    {
        printf("\nPage Replacement Algorithms\n1.Enter data\n2.FIFO\n3.Optimal\n4.LRU\n5.LFU\n6.Second Chance\n7.Exit\nEnter your choice:");
        scanf("%d",&choice);
        switch(choice)
        {
        case 1:
            getData();
            break;
        case 2:
            fifo();
            break;
        case 3:
            optimal();
            break;
        case 4:
            lru();
            break;
        case 5:
            lfu();
            break;
        case 6:
            secondchance();
            break;
        default:
            return 0;
            break;
        }
    }
}



/////optimal page replacement algo


#include<stdio.h>

int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos, max, faults = 0;
    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);

    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);

    printf("Enter page reference string: ");

    for(i = 0; i < no_of_pages; ++i){
        scanf("%d", &pages[i]);
    }

    for(i = 0; i < no_of_frames; ++i){
        frames[i] = -1;
    }

    for(i = 0; i < no_of_pages; ++i){
        flag1 = flag2 = 0;

        for(j = 0; j < no_of_frames; ++j){
            if(frames[j] == pages[i]){
                   flag1 = flag2 = 1;
                   break;
               }
        }

        if(flag1 == 0){
            for(j = 0; j < no_of_frames; ++j){
                if(frames[j] == -1){
                    faults++;
                    frames[j] = pages[i];
                    flag2 = 1;
                    break;
                }
            }
        }

        if(flag2 == 0){
            flag3 =0;

            for(j = 0; j < no_of_frames; ++j){
                temp[j] = -1;

                for(k = i + 1; k < no_of_pages; ++k){
                    if(frames[j] == pages[k]){
                        temp[j] = k;
                        break;
                    }
                }
            }

            for(j = 0; j < no_of_frames; ++j){
                if(temp[j] == -1){
                    pos = j;
                    flag3 = 1;
                    break;
                }
            }

            if(flag3 ==0){
                max = temp[0];
                pos = 0;

                for(j = 1; j < no_of_frames; ++j){
                    if(temp[j] > max){
                        max = temp[j];
                        pos = j;
                    }
                }
            }

            frames[pos] = pages[i];
            faults++;
        }

        printf("\n");

        for(j = 0; j < no_of_frames; ++j){
            printf("%d\t", frames[j]);
        }
    }

    printf("\n\nTotal Page Faults = %d", faults);

    return 0;
}



//////////////////////lru


#include<stdio.h>
 
int findLRU(int time[], int n){
    int i, minimum = time[0], pos = 0;
 
    for(i = 1; i < n; ++i){
        if(time[i] < minimum){
            minimum = time[i];
            pos = i;
        }
    }
    
    return pos;
}
 
int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], counter = 0, time[10], flag1, flag2, i, j, pos, faults = 0;
    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);
    
    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);
    
    printf("Enter reference string: ");
    
    for(i = 0; i < no_of_pages; ++i){
        scanf("%d", &pages[i]);
    }
    
    for(i = 0; i < no_of_frames; ++i){
        frames[i] = -1;
    }
    
    for(i = 0; i < no_of_pages; ++i){
        flag1 = flag2 = 0;
        
        for(j = 0; j < no_of_frames; ++j){
            if(frames[j] == pages[i]){
                counter++;
                time[j] = counter;
                   flag1 = flag2 = 1;
                   break;
               }
        }
        
        if(flag1 == 0){
            for(j = 0; j < no_of_frames; ++j){
                if(frames[j] == -1){
                    counter++;
                    faults++;
                    frames[j] = pages[i];
                    time[j] = counter;
                    flag2 = 1;
                    break;
                }
            }    
        }
        
        if(flag2 == 0){
            pos = findLRU(time, no_of_frames);
            counter++;
            faults++;
            frames[pos] = pages[i];
            time[pos] = counter;
        }
        
        printf("\n");
        
        for(j = 0; j < no_of_frames; ++j){
            printf("%d\t", frames[j]);
        }
    }
    
    printf("\n\nTotal Page Faults = %d", faults);
    
    return 0;
}


///////////////fifo page replacement
#include<stdio.h>
int main()
{
int i,j,n,a[50],frame[10],no,k,avail,count=0;
            printf("\n ENTER THE NUMBER OF PAGES:\n");
scanf("%d",&n);
            printf("\n ENTER THE PAGE NUMBER :\n");
            for(i=1;i<=n;i++)
            scanf("%d",&a[i]);
            printf("\n ENTER THE NUMBER OF FRAMES :");
            scanf("%d",&no);
for(i=0;i<no;i++)
            frame[i]= -1;
                        j=0;
                        printf("\tref string\t page frames\n");
for(i=1;i<=n;i++)
                        {
                                    printf("%d\t\t",a[i]);
                                    avail=0;
                                    for(k=0;k<no;k++)
if(frame[k]==a[i])
                                                avail=1;
                                    if (avail==0)
                                    {
                                                frame[j]=a[i];
                                                j=(j+1)%no;
                                                count++;
                                                for(k=0;k<no;k++)
                                                printf("%d\t",frame[k]);
}
                                    printf("\n");
}
                        printf("Page Fault Is %d",count);
                        return 0;
}

//////////////lfu page replacement in c


#include<stdio.h>

int main()
{
      int total_frames, total_pages, hit = 0;
      int pages[25], frame[10], arr[25], time[25];
      int m, n, page, flag, k, minimum_time, temp;
      printf("Enter Total Number of Pages:\t");
      scanf("%d", &total_pages);
      printf("Enter Total Number of Frames:\t");
      scanf("%d", &total_frames);
      for(m = 0; m < total_frames; m++)
      {
            frame[m] = -1;
      }
      for(m = 0; m < 25; m++)
      {
            arr[m] = 0;
      }
      printf("Enter Values of Reference String\n");
      for(m = 0; m < total_pages; m++)
      {
            printf("Enter Value No.[%d]:\t", m + 1);
            scanf("%d", &pages[m]);
      }
      printf("\n");
      for(m = 0; m < total_pages; m++)
      {
            arr[pages[m]]++;
            time[pages[m]] = m;
            flag = 1;
            k = frame[0];
            for(n = 0; n < total_frames; n++)
            {
                  if(frame[n] == -1 || frame[n] == pages[m])
                  {
                        if(frame[n] != -1)
                        {
                              hit++;
                        }
                        flag = 0;
                        frame[n] = pages[m];
                        break;
                  }
                  if(arr[k] > arr[frame[n]])
                  {
                        k = frame[n];
                  }
            }
            if(flag)
            {
                  minimum_time = 25;
                  for(n = 0; n < total_frames; n++)
                  {
                        if(arr[frame[n]] == arr[k] && time[frame[n]] < minimum_time)
                        {
                              temp = n;
                              minimum_time = time[frame[n]];
                        }
                  }
                  arr[frame[temp]] = 0;
                  frame[temp] = pages[m];
            }
            for(n = 0; n < total_frames; n++)
            {
                  printf("%d\t", frame[n]);
            }
            printf("\n");
      }
      printf("Page Hit:\t%d\n", hit);
      return 0;
}



//////mfu


#include<stdio.h>
#include<conio.h>
struct node
{
  int pno,freq;
}frames[20];
int n;

int page_found(int pno)
{
  int fno;
  for(fno=0;fno<n;fno++)
    if(frames[fno].pno==pno)
       return fno;
    return -1;
}

int get_free_frame()
{  int fno;
  for (fno=0; fno<=n; fno++)
    if (frames[fno].pno==-1)
        return(fno);
   return(-1);
}

int get_mfu_frame()
{
  int fno;
  int selfno=0;
  for (fno=1; fno<n; fno++)
    if(frames[fno].freq>frames[selfno].freq)
    selfno=fno;
  return selfno;
}
void main()
{
   int p_request[]={5,8,10,14,10,9,5,10,8,5,1,10,9,12,10};
   int size=15;
   int page_falts=0,i,j,fno;

   printf("\nHow many frames:");  scanf("%d",&n);
   //initialize frames
   for (i=0; i<n; i++)
   { frames[i].pno=-1;
     frames[i].freq=0;
   }

   printf("\nPageNo     Page Frames              Page Fault");
   printf("\n---------------------------------------------------");
   for(i=0;i<size;i++)
   {
     j=page_found(p_request[i]);
     if(j==-1)  //page fault occurs
     {
       j=get_free_frame();
       if (j==-1) //no free frame - do page replacement
         j=get_mfu_frame();
       page_falts++;
       frames[j].pno=p_request[i];
       frames[j].freq=1;
       printf("\n%4d\t ",p_request[i]);
       for (fno=0; fno<n; fno++)
         printf("%4d:%2d",frames[fno].pno,frames[fno].freq);
       printf(" : YES");
     }
    else //page found in frame j
    {
       printf("\n%4d\t ",p_request[i]);
       frames[j].freq++;
       for (fno=0; fno<n; fno++)
         printf("%4d:%2d",frames[fno].pno,frames[fno].freq);
       printf(" : NO");
    }
   }
  printf("\n-------------------------------------------------------");
  printf("\n Number of Page_Falts=%d",page_falts);
  getch();
}


//////////////////mfu

#include<stdio.h>
#include<conio.h>
struct node
{
  int pno,freq;
}frames[20];
int n;

int page_found(int pno)
{
  int fno;
  for(fno=0;fno<n;fno++)
    if(frames[fno].pno==pno)
       return fno;
    return -1;
}

int get_free_frame()
{  int fno;
  for (fno=0; fno<=n; fno++)
    if (frames[fno].pno==-1)
        return(fno);
   return(-1);
}

int get_mfu_frame()
{
  int fno;
  int selfno=0;
  for (fno=1; fno<n; fno++)
    if(frames[fno].freq>frames[selfno].freq)
    selfno=fno;
  return selfno;
}
int main()
{
   int p_request[100],x,size=0;
   int page_falts=0,i,j,fno;
   printf("\nEnter the number of frames:");
   scanf("%d",&n);
   printf("\nEnter the number of page request:");
   scanf("%d",&x);
   size=x;
   printf("\nEnter the page request");
   for(i=0;i<x;i++)
   {
       scanf("%d",&p_request[i]);
   }
   for (i=0; i<n; i++)
   { frames[i].pno=-1;
     frames[i].freq=0;
   }

   printf("\nPageNo     Page Frames              Page Fault");
   printf("\n---------------------------------------------------");
   for(i=0;i<size;i++)
   {
     j=page_found(p_request[i]);
     if(j==-1)
     {
       j=get_free_frame();
       if (j==-1)
         j=get_mfu_frame();
       page_falts++;
       frames[j].pno=p_request[i];
       frames[j].freq=1;
       printf("\n%4d\t ",p_request[i]);
       for (fno=0; fno<n; fno++)
         printf("%4d:%2d",frames[fno].pno,frames[fno].freq);
       printf(" : YES");
     }
    else
    {
       printf("\n%4d\t ",p_request[i]);
       frames[j].freq++;
       for (fno=0; fno<n; fno++)
         printf("%4d:%2d",frames[fno].pno,frames[fno].freq);
       printf(" : NO");
    }
   }
  printf("\n-------------------------------------------------------");
  printf("\n Number of Page_Falts=%d",page_falts);
}


//////////////////////disk scheduling
#include<stdio.h>
int absolute(int a,int b)
    {int c;
     c=a-b;
     if(c<0)
            return -c;
     else
         return c;
         }
int main()
    {
     printf("MENU DRIVEN C CODE FOR DISK SCHEDULING ALGORITHMS BY challa karthik
            ");
     int choice,m,n,x,start,i,j,pos,min,a[15],count;
     count=0;
     printf("\nEnter the number of cylinders :");
     scanf("%d",&m);
     printf("\nEnter the number of requests :");
     scanf("%d",&n);
     printf("\nEnter current position :");
     scanf("%d",&start);
     printf("\nEnter the request queue :");
     for(i=0;i<n;i++)
                     {scanf("%d",&a[i]);
                      if(a[i]>=m)
                                 {printf("\ninvalid input");
                                  scanf("%d",&a[i]);
                                  }
                      }
     do
       {printf("\n\nDISK SCHEDULING ALGORITHMS\n1. FCFS\n2. SSTF\n3. SCAN\n4. C-SCAN\n5. LOOK\n6. C-LOOK");
        printf("\nEnter choice :");
        scanf("%d",&choice);
        count=0;
        x=start;
        switch(choice)
                      {case 1:printf("\nFCFS :\n");
                              printf("Scheduling services the request in the order that follows:\n%d\t",start);
                              for(i=0;i<n;i++)
                                              {x-=a[i];
                                               if(x<0)
                                                      x=-x;
                                               count+=x;
                                               x=a[i];
                                               printf("%d\t",x);
                                               }
                              printf("\nTotal Head Movement :%d Cylinders",count);
                              break;
                       case 2:printf("\nSSTF :\n");
                              printf("Scheduling services the request in the order that follows:\n%d\t",start);
                              for(i=0;i<n;i++)
                                              {min=absolute(a[i],x);
                                               pos=i;
                                               for(j=i;j<n;j++)
                                                               if(min>absolute(x,a[j]))
                                                                                 {pos=j;
                                                                                  min=absolute(x,a[j]);
                                                                                  }
                                               count+=absolute(x,a[pos]);
                                               x=a[pos];
                                               a[pos]=a[i];
                                               a[i]=x;
                                               printf("%d\t",x);
                                               }
                              printf("\nTotal Head Movement: %d Cylinders",count);
                              break;
                       case 3:printf("\nC-SCAN :\n");
                              printf("Scheduling services the request in the order that follows:\n");
                              count=0;
                              pos=0;
                              for(i=0;i<n;i++)
                                              for(j=0;j<n-i-1;j++)
                                                              if(a[j]>a[j+1])
                                                                             {x=a[j];
                                                                              a[j]=a[j+1];
                                                                              a[j+1]=x;
                                                                              }
                              for(i=0;i<n;i++)
                                              if(a[i]<start)
                                                            pos++;
                              for(i=0;i<pos;i++)
                                              for(j=0;j<pos-i-1;j++)
                                                                if(a[j]<a[j+1])
                                                                               {x=a[j];
                                                                                a[j]=a[j+1];
                                                                                a[j+1]=x;
                                                                                }
                              x=start;
                              printf("%d\t",x);
                              for(i=0;i<pos;i++)
                                                {count+=absolute(a[i],x);
                                                 x=a[i];
                                                 printf("%d\t",x);
                                                 }
                              count+=absolute(x,0);
                              x=0;
                              printf("%d\t",x);
                              for(i=pos;i<n;i++)
                                                {count+=absolute(a[i],x);
                                                 x=a[i];
                                                 printf("%d\t",x);
                                                 }
                              /*for(i=0;i<n;i++)
                                              printf("%d\t",a[i]);*/
                              printf("\nTotal Head Movement: %d Cylinders",count);
                              break;
                       case 4:printf("\nC-SCAN :\n");
                              printf("Scheduling Services the request in the order that follows:\n%d\t",start);
                              count=0;
                              pos=0;
                              for(i=0;i<n;i++)
                                              for(j=0;j<n-i-1;j++)
                                                              if(a[j]>a[j+1])
                                                                             {x=a[j];
                                                                              a[j]=a[j+1];
                                                                              a[j+1]=x;
                                                                              }
                             for(i=0;i<n;i++)
                                             if(a[i]<start)
                                                           pos++;
                             x=start;
                             for(i=pos;i<n;i++)
                                               {count+=absolute(x,a[i]);
                                                x=a[i];
                                                printf("%d\t",x);
                                                }
                             count+=absolute(m-1,x);
                             x=0;
                             printf("%d\t%d\t",m-1,0);
                             for(i=0;i<pos;i++)
                                                {count+=absolute(x,a[i]);
                                                 x=a[i];
                                                 printf("%d\t",x);
                                                 }
                             /*for(i=0;i<n;i++)
                                             printf("%d\t",a[i]);*/
                             printf("\nTotal Head movement: %d Cylinders",count);
                             break;
                      case 5:printf("\nLOOK :\n");
                             printf("\nScheduling services the request in the order as follows :\n%d\t",start);
                             count=0;
                             pos=0;
                             for(i=0;i<n;i++)
                                             for(j=0;j<n-i-1;j++)
                                                                 if(a[j]>a[j+1])
                                                                                {x=a[j];
                                                                                 a[j]=a[j+1];
                                                                                 a[j+1]=x;
                                                                                 }
                             for(i=0;i<n;i++)
                                             if(a[i]<start)
                                                           pos++;
                             for(i=0;i<pos;i++)
                                               for(j=0;j<pos-i-1;j++)
                                                                     if(a[j]<a[j+1])
                                                                                    {x=a[j];
                                                                                     a[j]=a[j+1];
                                                                                     a[j+1]=x;
                                                                                     }
                             x=start;
                             for(i=0;i<pos;i++)
                                               {count+=absolute(a[i],x);
                                                x=a[i];
                                                printf("%d\t",x);
                                                }
                             for(i=pos;i<n;i++)
                                                {count+=absolute(a[i],x);
                                                 x=a[i];
                                                 printf("%d\t",x);
                                                 }
                             printf("\nToal Head Movement: %d Cylinders",count);
                             break;
                      case 6:printf("\nC-LOOK :\n");
                              printf("Scheduling Services the request in the order that follows:\n%d\t",start);
                              count=0;
                              pos=0;
                              for(i=0;i<n;i++)
                                              for(j=0;j<n-i-1;j++)
                                                              if(a[j]>a[j+1])
                                                                             {x=a[j];
                                                                              a[j]=a[j+1];
                                                                              a[j+1]=x;
                                                                              }
                             for(i=0;i<n;i++)
                                             if(a[i]<start)
                                                           pos++;
                             x=start;
                             for(i=pos;i<n;i++)
                                               {count+=absolute(x,a[i]);
                                                x=a[i];
                                                printf("%d\t",x);
                                                }
                             for(i=0;i<pos;i++)
                                                {count+=absolute(x,a[i]);
                                                 x=a[i];
                                                 printf("%d\t",x);
                                                 }
                             /*for(i=0;i<n;i++)
                                             printf("%d\t",a[i]);*/
                             printf("\nTotal Head movement: %d Cylinders",count);
                             break;
                       }
        printf("\nDo you want to continue(1 to continue) :");
        scanf("%d",&choice);
        }while(choice==1);


///////////////////////all sepearte disk scheduling
/////disk scheduling


///fcfs 
#include<stdio.h>
#include<conio.h>
void main()
{
             int queue[100],n,head,i,j,k,seek=0,diff;
             float avg;
             // clrscr();
             printf("*** FCFS Disk Scheduling Algorithm ***\n");
             printf("Enter the size of Queue\t");
             scanf("%d",&n);
             printf("Enter the Queue\t");
             for(i=1;i<=n;i++)
             {
                          scanf("%d",&queue[i]);
             }
             printf("Enter the initial head position\t");
             scanf("%d",&head);
             queue[0]=head;
             printf("\n");
             for(j=0;j<=n-1;j++)
             {
                          diff=abs(queue[j+1]-queue[j]);
                          seek+=diff;
                          printf("Move from %d to %d with Seek %d\n",queue[j],queue[j+1],diff);
             }
             printf("\nTotal Seek Time is %d\t",seek);
             avg=seek/(float)n;
             printf("\nAverage Seek Time is %f\t",avg);
             getch();
}


orrr


#include<conio.h>
#include<stdio.h>
int main()
{
 int i,j,sum=0,n;
 int ar[20],tm[20];
 int disk;

 printf("enter number of location\t");
 scanf("%d",&n);
 printf("enter position of head\t");
 scanf("%d",&disk);
 printf("enter elements of disk queue\n");
 for(i=0;i<n;i++)
 {
 scanf("%d",&ar[i]);
 tm[i]=disk-ar[i];
 if(tm[i]<0)
 {
 tm[i]=ar[i]-disk;
 }
 disk=ar[i];
 sum=sum+tm[i];
 }
 /*for(i=0;i<n;i++)
 {
 printf("\n%d",tm[i]);
 }   */
 printf("\nmovement of total cylinders %d",sum);
 getch();
 return 0;
}



//////sstf scheduling

#include<stdio.h>
#include<conio.h>
#include<math.h>
void main()
{
             int queue[100],t[100],head,seek=0,n,i,j,temp;
             float avg;
         // clrscr();
             printf("*** SSTF Disk Scheduling Algorithm ***\n");
             printf("Enter the size of Queue\t");
             scanf("%d",&n);
             printf("Enter the Queue\t");
             for(i=0;i<n;i++)
             {
                          scanf("%d",&queue[i]);
             }
             printf("Enter the initial head position\t");
             scanf("%d",&head);
             for(i=1;i<n;i++)
             t[i]=abs(head-queue[i]);
             for(i=0;i<n;i++)
             {
                          for(j=i+1;j<n;j++)
                          {
                                       if(t[i]>t[j])
                                       {
                                                    temp=t[i];
                                                    t[i]=t[j];
                                                    t[j]=temp;
                                                    temp=queue[i];
                                                    queue[i]=queue[j];
                                                    queue[j]=temp;
                                       }
                         }
             }
             for(i=1;i<n-1;i++)
             {
                          seek=seek+abs(head-queue[i]);
                          head=queue[i];
             }
             printf("\nTotal Seek Time is%d\t",seek);
             avg=seek/(float)n;
             printf("\nAverage Seek Time is %f\t",avg);
             getch();
}



orr


#include<stdio.h>

struct head
{
      int num;
      int flag;
};

int main()
{
      struct head h[33];
      int array_1[33], array_2[33];
      int count = 0, j, x, limit, minimum, location, disk_head, sum = 0;
      printf("\nEnter total number of locations:\t");
      scanf("%d", &limit);
      printf("\nEnter position of disk head:\t");
      scanf("%d", &disk_head);
      printf("\nEnter elements of disk head queue\n");
      while(count < limit)
      {
            scanf("%d", &h[count].num);
            h[count].flag = 0;
            count++;
      }
      for(count = 0; count < limit; count++)
      {
            x = 0;
            minimum = 0;
            location = 0;
            for(j = 0; j < limit; j++)
            {
                  if(h[j].flag == 0)
                  {
                        if(x == 0)
                        {
                              array_1[j] = disk_head - h[j].num;
                              if(array_1[j] < 0)
                              {
                                    array_1[j] = h[j].num - disk_head;
                              }
                              minimum = array_1[j];
                              location = j;
                              x++;
                        }
                        else
                        {
                              array_1[j] = disk_head - h[j].num;
                              if(array_1[j] < 0)
                              {
                                    array_1[j] = h[j].num - disk_head;
                              }
                        }
                        if(minimum > array_1[j])
                        {
                              minimum = array_1[j];
                              location = j;
                        }
                  }
            }
            h[location].flag = 1;
            array_2[count] = h[location].num - disk_head;
            if(array_2[count] < 0)
            {
                  array_2[count] = disk_head - h[location].num;
            }
            disk_head = h[location].num;
      }
      count = 0;
      while(count < limit)
      {
            sum = sum + array_2[count];
            count++;
      }
      printf("\nTotal movements of the cylinders:\t%d", sum);
      return 0;
}



//////////scan 
#include<conio.h>
#include<stdio.h>
int main()
{
 int i,j,sum=0,n;
 int d[20];
 int disk;   //loc of head
 int temp,max;
 int dloc;   //loc of disk in array

 printf("enter number of location\t");
 scanf("%d",&n);
 printf("enter position of head\t");
 scanf("%d",&disk);
 printf("enter elements of disk queue\n");
 for(i=0;i<n;i++)
 {
 scanf("%d",&d[i]);
 }
 d[n]=disk;
 n=n+1;
 for(i=0;i<n;i++)    // sorting disk locations
 {
  for(j=i;j<n;j++)
  {
    if(d[i]>d[j])
    {
    temp=d[i];
    d[i]=d[j];
    d[j]=temp;
    }
  }
 }
 max=d[n];
 for(i=0;i<n;i++)   // to find loc of disc in array
 {
 if(disk==d[i]) { dloc=i; break;  }
 }
 for(i=dloc;i>=0;i--)
 {
 printf("%d -->",d[i]);
 }
 printf("0 -->");
 for(i=dloc+1;i<n;i++)
 {
 printf("%d-->",d[i]);
 }
 sum=disk+max;
       printf("\nmovement of total cylinders %d",sum);
 getch();
 return 0;
}


orrrrr



#include<stdio.h>
#include<conio.h>

void scan_algorithm(int left[], int right[], int count, int limit)
{
      int arr[20];
      int x = count - 1, y = count + 1, c = 0, d = 0, j;
      while(x > -1)
      {
            printf("\nX:\t%d", x);
            printf("\nLeft[X]:\t%d", left[x]);
            arr[d] = left[x];
            x--;
            d++;
      }
      arr[d] = 0;
      while(y < limit + 1)
      {
            arr[y] = right[c];
            c++;
            y++;
      }
      printf("\nScanning Order:\n");
      for(j = 0; j < limit + 1; j++)
      {
            printf("\n%d", arr[j]);
      }
}

void division(int elements[], int limit, int disk_head)
{
      int count = 0, p, q, m, x;
      int left[20], right[20];
      for(count = 0; count < limit; count++)
      {
            if(elements[count] > disk_head)
            {
                  printf("\nBreak Position:\t%d\n", elements[count]);
                  break;
            }
      }
      printf("\nValue:\t%d\n", count);
      q = 1;
      p = 0;
      m = limit;
      left[0] = elements[0];
      printf("\nLeft:\t%d", left[0]);
      while(q < count)
      {
            printf("\nElement[l] value:\t%d" , elements[q]);
            left[q] = elements[q];
            printf("\nLeft:\t%d", left[q]);
            q++;
            printf("\nl:\t%d", q);
      }
      x = count;
      while(x < m)
      {
            right[p] = elements[x];
            printf("\nRight:\t%d", right[p]);
            printf("\nElement:\t%d", elements[x]);
            p++;
            x++;
      }
      scan_algorithm(left, right, count, limit);
}

void sorting(int elements[], int limit)
{
      int location, count, j, temp, small;
      for(count = 0; count < limit - 1; count++)
      {
            small = elements[count];
            location = count;
            for(j = count + 1; j < limit; j++)
            {
                  if(small > elements[j])
                  {
                        small = elements[j];
                        location = j;
                  }
            }
            temp = elements[location];
            elements[location] = elements[count];
            elements[count] = temp;
      }
}

int main()
{
      int count, disk_head, elements[20], limit;
      printf("Enter total number of locations:\t");
      scanf("%d", &limit);
      printf("\nEnter position of disk head:\t");
      scanf("%d", &disk_head);
      printf("\nEnter elements of disk head queue\n");
      for(count = 0; count < limit; count++)
      {
            printf("Element[%d]:\t", count + 1);
            scanf("%d", &elements[count]);
      }
      sorting(elements, limit);
      division(elements, limit, disk_head);
      getch();
      return 0;
}



////////////////c scan


#include<stdio.h>
#include<stdlib.h>

int main()
{
      int queue1[30], queue2[30], queue3[30];
      int limit, disk_head, count = 0, j, seek_time = 0, range, diff;
      int t1, t2 = 0, t3 = 0;
      float avg_seek_time;
      printf("Maximum Range of Disk:\t");
      scanf("%d", &range);
      printf("Initial Head Position:\t");
      scanf("%d", &disk_head);
      printf("Queue Request Size:\t");
      scanf("%d", &limit);
      printf("Disk Queue Element Positions:\n");
      while(count < limit)
      {
            scanf("%d", &t1);
            if(t1 >= disk_head)
            {
                  queue1[t2] = t1;
                  t2++;
            }
            else
            {
                  queue2[t3] = t1;
                  t3++;
            }
            count++;
      }
      count = 0;
      while(count < t2 - 1)
      {
            j = count + 1;
            while(j < t2)
            {
                  if(queue1[count] > queue1[j])
                  {
                        t1 = queue1[count];
                        queue1[count] = queue1[j];
                        queue1[j] = t1;
                  }
                  j++;
            }
            count++;
      }
      count = 0;
      while(count < t3 - 1)
      {
            j = count + 1;
            while(j < t3)
            {
                  if(queue2[count] > queue2[j])
                  {
                        t1 = queue2[count];
                        queue2[count] = queue2[j];
                        queue2[j] = t1;
                  }
                  j++;
            }
            count++;
      }
      count = 1;
      j = 0;
      while(j < t2)
      {
            queue3[count] = queue1[j];
            queue3[count] = range;
            queue3[count + 1] = 0;
            count++;
            j++;
      }
      count = t2 + 3;
      j = 0;
      while(j < t3)
      {
            queue3[count] = queue2[j];
            queue3[0] = disk_head;
            count++;
            j++;
      }
      for(j = 0; j <= limit + 1; j++)
      {
            diff = abs(queue3[j + 1] - queue3[j]);
            seek_time = seek_time + diff;
            printf("\nDisk Head:\t%d -> %d [Seek Time: %d]\n", queue3[j], queue3[j + 1], diff);
      }
      printf("\nTotal Seek Time:\t%d\n", seek_time);
      avg_seek_time = seek_time / (float)limit;
      printf("\nAverage Seek Time:\t%f\n", avg_seek_time);
      return 0;
}




orrrr



#include<stdio.h>
int main()
{
            int queue[20],n,head,i,j,k,seek=0,max,diff,temp,queue1[20],queue2[20],
                        temp1=0,temp2=0;
            float avg;
            printf("Enter the max range of disk\n");
            scanf("%d",&max);
            printf("Enter the initial head position\n");
            scanf("%d",&head);
            printf("Enter the size of queue request\n");
            scanf("%d",&n);
            printf("Enter the queue of disk positions to be read\n");
            for(i=1;i<=n;i++)
            {
                        scanf("%d",&temp);
                        if(temp>=head)
                        {
                                    queue1[temp1]=temp;
                                    temp1++;
                        }
                        else
                        {
                                    queue2[temp2]=temp;
                                    temp2++;
                        }
            }
            for(i=0;i<temp1-1;i++)
            {
                        for(j=i+1;j<temp1;j++)
                        {
                                    if(queue1[i]>queue1[j])
                                    {
                                                temp=queue1[i];
                                                queue1[i]=queue1[j];
                                                queue1[j]=temp;
                                    }
                        }
            }
            for(i=0;i<temp2-1;i++)
            {
                        for(j=i+1;j<temp2;j++)
                        {
                                    if(queue2[i]>queue2[j])
                                    {
                                                temp=queue2[i];
                                                queue2[i]=queue2[j];
                                                queue2[j]=temp;
                                    }
                        }
            }
            for(i=1,j=0;j<temp1;i++,j++)
            queue[i]=queue1[j];
            queue[i]=max;
            queue[i+1]=0;
            for(i=temp1+3,j=0;j<temp2;i++,j++)
            queue[i]=queue2[j];
            queue[0]=head;
            for(j=0;j<=n+1;j++)
            {
                        diff=abs(queue[j+1]-queue[j]);
                        seek+=diff;
                        printf("Disk head moves from %d to %d with seek                                                                           %d\n",queue[j],queue[j+1],diff);
            }
            printf("Total seek time is %d\n",seek);
            avg=seek/(float)n;
            printf("Average seek time is %f\n",avg);
            return 0;
}



/////look

#include<math.h>
#include<stdio.h>
int main()
{
    int i,n,j=0,k=0,x=0,l,req[50],mov=0,cp,ub,end, lower[50],upper[50], temp,a[50];
    printf("enter the current position\n");
    scanf("%d",&cp);
    printf("enter the number of requests\n");
    scanf("%d",&n);
    printf("enter the request order\n");
    for(i=0;i<n;i++)
    {
        scanf("%d",&req[i]);
    }
    printf("Enter the upper bound\n");
    scanf("%d",&ub);

    /*break the request array into two arrays : one with requests lower than current and other with requests higher than current position. Also sort these two new arrays*/
    for(i=0;i<n;i++)
    {
        if(req[i]<cp)
        {
            lower[j]=req[i];
            j++;
        }
        if(req[i]>cp)
        {
            upper[k]=req[i];
            k++;
        }
    }

    //sort the lower array in reverse order
    for(i=0;i<j;i++)
    {
        for(l=0;l<j-1;l++)
        {
            if(lower[l]<lower[l+1])
            {
                temp=lower[l];
                lower[l]=lower[l+1];
                lower[l+1]=temp;
            }
        }
    }

    // sort the upper array in ascending order
    for(i=0;i<=k;i++)
    {
        for(l=0;l<k-1;l++)
        {
            if(upper[l]>upper[l+1])
            {
                temp=upper[l];
                upper[l]=upper[l+1];
                upper[l+1]=temp;
            }
        }
    }

    printf("Enter the end to which the head is moving (0 - for lower end(zero) and 1 - for upper end\n");
    scanf("%d",&end);
    switch(end)
    {
        case 0:
            for(i=0;i<j;i++)
            {
                a[x]=lower[i];
                x++;
            }

            for(i=0;i<k;i++)
            {
                a[x]=upper[i];
                x++;
            }
        break;
        case 1:
            for(i=0;i<k;i++)
            {
                a[x]=upper[i];
                x++;
            }

            for(i=0;i<j;i++)
            {
                a[x]=lower[i];
                x++;
            }
        break;
    }

    mov=mov+abs(cp-a[0]);
    printf("%d -> %d",cp,a[0]);
    for(i=1;i<x;i++)
    {
        mov=mov+abs(a[i]-a[i-1]);
        printf(" -> %d",a[i]);
    }
    printf("\n");
    printf("total head movement = %d\n",mov);
}





//////////////c look

#include<stdio.h>
#include<conio.h>
#include<math.h>
#define max 20
#define cymax 199

int i,j,req,ttl_tracks=0,cp,np,cposn,nposn;
int cyposn[max],temp;

void input()
{
 do
 {

  printf("\n Enter the current header position : ");
  scanf("%d",&cposn);
 }while(cposn>cymax || cposn <=0);
 printf("\n Enter the %d I/O Requests : ",req);
 cyposn[0] = cposn;
 for(i=1;i<=req;i++)
  scanf("%d",&cyposn[i]);
}

void CLOOK()
{
 for(i=0;i<=req;i++)
 {
  for(j=0;j<req-i;j++)
  {
   if(cyposn[j] > cyposn[j+1])
   {
    temp = cyposn[j];
    cyposn[j] = cyposn[j+1];
    cyposn[j+1] = temp;
   }
  }
 }
 cp=0;
 do
 {
  if(cyposn[cp] == cposn)
   break;
  cp++;
 }while(cp!=req);
 printf("\nS.No.  Current Position    Next Position   Displacement \n");
 printf("---------------------------------------------------------- \n\n");
 i=0,j=cp;
 cposn = cyposn[cp];
 do
 {
  if(cp == req)
  { nposn = cyposn[0]; cp = 0; }
  else
   nposn = cyposn[++cp];
  printf(" %d\t\t%d\t\t%d\t\t%d\n",++i,cposn,nposn,abs(cposn-nposn));
  ttl_tracks += (abs(cposn-nposn));
  cposn = nposn == cyposn[req] ? cyposn[0] : nposn ;
 }while(nposn != cyposn[j-1]);
 printf("---------------------------------------------------------- \n\n");
 printf(" Total Tracks Displaced : %d",ttl_tracks);
}

void main()
{
 do
 {

  printf("\n Enter the number of requests : ");
  scanf("%d",&req);
 }while(req>max || req <=0);
 input();
 CLOOK();
 getch();
}



     }


/////////////////////////////disk scheduling

#include<stdio.h>
#include<math.h>

void fcfs(int noq, int qu[10], int st)
{
 int i,s=0;
 for(i=0;i<noq;i++)
 {
  s=s+abs(st-qu[i]);
  st=qu[i];
  }
 printf("\n Total seek time :%d",s);
}

void sstf(int noq, int qu[10], int st, int visit[10])
{
 int min,s=0,p,i;
 while(1)
{
  min=999;
  for(i=0;i<noq;i++)
   if (visit[i] == 0)
    {
      if(min > abs(st - qu[i]))
       {
        min = abs(st-qu[i]);
        p = i;
        }
      }
 if(min == 999)
  break;
  visit[p]=1;
  s=s + min;
  st = qu[p];
  }
 printf("\n Total seek time is: %d",s);
 }

void scan(int noq, int qu[10], int st, int ch)
{
 int i,j,s=0;
 for(i=0;i<noq;i++)
 {
  if(st < qu[i])
  {
   for(j=i-1; j>= 0;j--)
   {
    s=s+abs(st - qu[j]);
    st = qu[j];
    }
   if(ch == 3)
   {
   s = s + abs(st - 0);
   st = 0;
   }
  for(j = 1;j < noq;j++)
  {
   s= s + abs(st - qu[j]);
   st = qu[j];
   }
  break;
 }
}
printf("\n Total seek time : %d",s);
}

int main()
{
 int n,qu[20],st,i,j,t,noq,ch,visit[20];
 printf("\n Enter the maximum number of cylinders : ");
 scanf("%d",&n);
 printf("enter number of queue elements");
 scanf("%d",&noq);
 printf("\n Enter the work queue");
 for(i=0;i<noq;i++)
 {
  scanf("%d",&qu[i]);
  visit[i] = 0;
  }
 printf("\n Enter the disk head starting posision: \n");
 scanf("%d",&st);
 while(1)
 {
  printf("\n\n\t\t MENU \n");
  printf("\n\n\t\t 1. FCFS \n");
  printf("\n\n\t\t 2. SSTF \n");
  printf("\n\n\t\t 3. SCAN \n");
  printf("\n\n\t\t 4. EXIT \n");
  printf("\nEnter your choice: ");
  scanf("%d",&ch);
  if(ch > 2)
   {
   for(i=0;i<noq;i++)
   for(j=i+1;j<noq;j++)
   if(qu[i]>qu[j])
   {
    t=qu[i];
    qu[i] = qu[j];
    qu[j] = t;
    }
   }
   switch(ch)
    {
    case 1: printf("\n FCFS \n");
            printf("\n*****\n");
            fcfs(noq,qu,st);
            break;

    case 2: printf("\n SSTF \n");
            printf("\n*****\n");
            sstf(noq,qu,st,visit);
            break;
    case 3: printf("\n SCAN \n");
            printf("\n*****\n");
            scan(noq,qu,st,ch);
            break;
    case 4: exit(0);
 }
 }
}



//////////////////////disk sceduling

//Basic Disk Scheduling
#include<stdio.h>
#include<conio.h>
#include<math.h>

void fcfs(int a[]);
void sstf(int a[]);
void scan(int a[]);



void main()
{
int n, a[10], ch, i;
printf("enter 10 cylinders numbers");
for(i=0; i<10; i++)
{
scanf("%d", &a[i]);
}



run:
{


printf("\n\n which algo do u want to use?");
printf("\n1) FCFS\n2)SSTF\n3)SCAN\n4)EXIT\n");
scanf("%d", &ch);

switch(ch)
{


      case 1: fcfs(a);
	      goto run;

      case 2: sstf(a);
	      goto run;

      case 3: scan(a);
	      goto run;

      case 4: exit(0);

      default: printf("please enter a valid choice");
	       goto run;

      }
      }
getch();
}

void fcfs(int a[])
{
int order[10], i, x, count=0, ptr;

printf("\n current pointer location");
scanf("%d", &ptr);
for(i=0; i<10; i++)
{
order[i] = a[i];
}
x= ptr- a[0];
if(x>0)
count=x;
else
count= -x;


for(i=1; i<10; i++)
{
x= a[i] - a[i-1];
if(x<0)
count =count+ (-x);
else
count =count+  x;
}

printf("Execution order:\n");
for(i=0; i<10; i++)
{
printf("%d ", order[i]);
}

printf("\nTotal cost : %d", count);
}


void sstf(int a[])
{
int i, j, ptr, count, x, m=9, b[10], min=9999, temp;
printf("\n current pointer location");
scanf("%d", &ptr);
j=ptr;
for(i=0; i<10; i++)
{
b[i] =a[i];
}

while(m>=0)
{
min=9999;
i=m;
while(i>=0)
{
if(abs(b[i]-ptr)<min)
{
min= abs(b[i]-ptr);
x=i;

}
--i;
}
ptr=a[x];
temp= b[x];
b[x] = b[m];
b[m] = temp;
--m;
}

count = abs(j-b[9]);
printf("execution order:\n");
for(i=9; i>=1; i--)
{
printf("%d ", b[i]);
count =count+ abs(b[i]-b[i-1]);
}
printf("%d ", b[0]);
printf("\nTotal cost : %d", count);



}


void scan(int a[])
{
  int ptr, b[11], i, j, min, x, temp;
 printf("\n current pointer location");
scanf("%d", &ptr);
b[0]= ptr;
for(i=0; i<10; i++)
{
b[i+1]= a[i];
}

for(i=0; i<10; i++)
{
min= i;
for(j=i+1; j<11; j++)
{
if(b[j]<b[min])
{
min = j;
}
}
temp = b[i];
b[i] = b[min];
b[min] = temp;
}


i=0;
while(b[i]!=ptr && i<11)
{
i++;
}
printf("\nExecution order :");
x=i;
i=x+1;
while(i!=x)
{
printf(" %d", b[i]);
i= (i+1)%11;
}


}

//////////////allocation strategies - all three

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main(){
menu();
 return 0;
}
 void menu()
 {
     int ch,f[50],p,i,st,len,j,c,k,a,index[50],ind,count=0;
     printf("\n\nMENU\n");
     printf("1.sequential\n2.indexed\n3.linked\n4.exit\n\nEnter your choice:");
     scanf("%d",&ch);
     if(ch==1)
     {
         int f[50], p,i, st, len, j, c, k, a;

for(i=0;i<50;i++)
f[i]=0;
printf("Enter how many blocks already allocated: ");
scanf("%d",&p);
printf("Enter blocks already allocated: ");
for(i=0;i<p;i++)
{
 scanf("%d",&a);
 f[a]=1;
}
x: printf("Enter index starting block and length: ");
scanf("%d%d", &st,&len);
k=len;
if(f[st]==0)
{
 for(j=st;j<(st+k);j++)
 {
 if(f[j]==0)
 {
 f[j]=1;
 printf("%d-------->%d\n",j,f[j]);
 }
 else
 {
 printf("%d Block is already allocated \n",j);
 k++;
 }
 }
}
else
printf("%d starting block is already allocated \n",st);
printf("Do you want to enter more file(Yes - 1/No - 0)");
scanf("%d", &c);
if(c==1)
 goto x;
else
 exit(0);
     }

 if(ch==2)
 {
     int f[50], index[50],i, n, st, len, j, c, k, ind,count=0;

for(i=0;i<50;i++)
f[i]=0;
printf("Enter the index block: ");
scanf("%d",&ind);
if(f[ind]!=1)
{
 printf("Enter no of blocks needed and no of files for the index %d on the disk : \n",
ind);
 scanf("%d",&n);
}
else
{
 printf("%d index is already allocated \n",ind);
 goto x;
}
y: count=0;
for(i=0;i<n;i++)
{
 scanf("%d", &index[i]);
 if(f[index[i]]==0)
 count++;
}
if(count==n)
{
 for(j=0;j<n;j++)
 f[index[j]]=1;
 printf("Allocated\n");
 printf("File Indexed\n");
 for(k=0;k<n;k++)
 printf("%d-------->%d : %d\n",ind,index[k],f[index[k]]);
}
else
{
printf("File in the index is already allocated \n");
printf("Enter another file indexed");
goto y;
}
printf("Do you want to enter more file(Yes - 1/No - 0)");
scanf("%d", &c);
if(c==1)
 goto x;
else
 exit(0);
 }

 if(ch==3){
        int f[50], i, st, len, j, c, k, count = 0;

for(i=0;i<50;i++)
f[i]=0;
printf("Files Allocated are : \n");
count=0;
printf("Enter starting block and length of files:");
scanf("%d%d", &st,&len);
for(k=st;k<(st+len);k++)
 if(f[k]==0)
 count++;
if(len==count)
{
 for(j=st;j<(st+len);j++)
 if(f[j]==0)
 {
 f[j]=1;
 printf("%d\t%d\n",j,f[j]);
 }
 if(j!=(st+len-1))
 printf(" The file is allocated to disk\n");
}
else
printf("The file is not allocated \n");
printf("Do you want to enter more file(Yes - 1/No - 0)");
scanf("%d", &c);
if(c==1)
 goto x;
else
 exit(0);
 }

 }

//////////////////
Sequential File Allocation Program:

#include
#include
main()
{
int f[50],i,st,j,len,c,k;
clrscr();
for(i=0;i<50;i++)
f[i]=0;
X:
printf("\n Enter the starting block & length of file");
scanf("%d%d",&st,&len);
for(j=st;j<(st+len);j++)
if(f[j]==0)
{
f[j]=1;
printf("\n%d->%d",j,f[j]);
}
else
{
printf("Block already allocated");
break;
}
if(j==(st+len))
printf("\n the file is allocated to disk");
printf("\n if u want to enter more files?(y-1/n-0)");
scanf("%d",&c);
if(c==1)
goto X;
else
exit();
getch();
}

orrrr

#include<stdio.h>
void main()
{
 int n,i,j,b[20],sb[20],t[20],x,c[20][20];
printf("Enter no.of files:");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
          printf("Enter no. of blocks occupied by file%d:",i+1);
          scanf("%d",&b[i]);
          printf("Enter the starting block of file%d:",i+1);
          scanf("%d",&sb[i]);
          t[i]=sb[i];
          for(j=0;j<b[i];j++)
                   c[i][j]=sb[i]++;
          }
 printf("Filename\tStart block\tlength\n");
 for(i=0;i<n;i++)
          printf("%d\t        %d \t           %d\n",i+1,t[i],b[i]);
}

orr

#include <stdio.h>
#include<conio.h>
void main()
{
int f[50], i, st, len, j, c, k, count = 0;

for(i=0;i<50;i++)
f[i]=0;
printf("Files Allocated are : \n");
x:count=0;
printf("Enter starting block and length of files: ");
scanf("%d%d", &st,&len);
for(k=st;k<(st+len);k++)
 if(f[k]==0)
 count++;
if(len==count)
{
 for(j=st;j<(st+len);j++)
 if(f[j]==0)
 {
 f[j]=1;
 printf("%d\t%d\n",j,f[j]);
 }
 if(j!=(st+len-1))
 printf(" The file is allocated to disk\n");
}
else
printf("The file is not allocated \n");
printf("Do you want to enter more file(Yes - 1/No - 0)");
scanf("%d", &c);
if(c==1)
 goto x;
else
 return 1;
getch();
}


///////////////indexd 


#include<stdio.h>
#include<conio.h>
main()
{
 int n,m[20],i,j,sb[20],s[20],b[20][20],x;

 printf("Enter no. of files:");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {       printf("Enter starting block and size of file%d:",i+1);
          scanf("%d%d",&sb[i],&s[i]);
          printf("Enter blocks occupied by file%d:",i+1);
          scanf("%d",&m[i]);
          printf("enter blocks of file%d:",i+1);
          for(j=0;j<m[i];j++)
                   scanf("%d",&b[i][j]);
 } printf("\nFile\t index\tlength\n");
 for(i=0;i<n;i++)
 {
          printf("%d\t%d\t%d\n",i+1,sb[i],m[i]);
 }printf("\nEnter file name:");
 scanf("%d",&x);
 printf("file name is:%d\n",x);
 i=x-1;
 printf("Index is:%d",sb[i]);
 printf("Block occupied are:");
 for(j=0;j<m[i];j++)
          printf("%3d",b[i][j]);
 getch();
}

or 
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
void main()
{
int f[50], index[50],i, n, st, len, j, c, k, ind,count=0;

for(i=0;i<50;i++)
f[i]=0;
x:printf("Enter the index block: ");
scanf("%d",&ind);
if(f[ind]!=1)
{
 printf("Enter no of blocks needed and no of files for the index %d on the disk : \n",
ind);
 scanf("%d",&n);
}
else
{
 printf("%d index is already allocated \n",ind);
 goto x;
}
y: count=0;
for(i=0;i<n;i++)
{
 scanf("%d", &index[i]);
 if(f[index[i]]==0)
 count++;
}
if(count==n)
{
 for(j=0;j<n;j++)
 f[index[j]]=1;
 printf("Allocated\n");
 printf("File Indexed\n");
 for(k=0;k<n;k++)
 printf("%d-------->%d : %d\n",ind,index[k],f[index[k]]);
}
else
{
printf("File in the index is already allocated \n");
printf("Enter another file indexed");
goto y;
}
printf("Do you want to enter more file(Yes - 1/No - 0)");
scanf("%d", &c);
if(c==1)
 goto x;
else
 exit(0);
getch();
}



/////linked 

#include<stdio.h>
#include<conio.h>
struct file
{
 char fname[10];
 int start,size,block[10];
}f[10];
main()
{
 int i,j,n;

 printf("Enter no. of files:");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
 printf("Enter file name:");
 scanf("%s",&f[i].fname);
 printf("Enter starting block:");
 scanf("%d",&f[i].start);
 f[i].block[0]=f[i].start;
 printf("Enter no.of blocks:");
 scanf("%d",&f[i].size);
 printf("Enter block numbers:");
 for(j=1;j<=f[i].size;j++)
 {
          scanf("%d",&f[i].block[j]);
 }
 }
 printf("File\tstart\tsize\tblock\n");
 for(i=0;i<n;i++)
 {
          printf("%s\t%d\t%d\t",f[i].fname,f[i].start,f[i].size);
          for(j=1;j<=f[i].size-1;j++)
                   printf("%d--->",f[i].block[j]);
          printf("%d",f[i].block[j]);
          printf("\n");
 }
 getch();
}


or 


#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
void main()
{
int f[50], p,i, st, len, j, c, k, a;

for(i=0;i<50;i++)
f[i]=0;
printf("Enter how many blocks already allocated: ");
scanf("%d",&p);
printf("Enter blocks already allocated: ");
for(i=0;i<p;i++)
{
 scanf("%d",&a);
 f[a]=1;
}
x: printf("Enter index starting block and length: ");
scanf("%d%d", &st,&len);
k=len;
if(f[st]==0)
{
 for(j=st;j<(st+k);j++)
 {
 if(f[j]==0)
 {
 f[j]=1;
 printf("%d-------->%d\n",j,f[j]);
 }
 else
 {
 printf("%d Block is already allocated \n",j);
 k++;
 }
 }
}
else
printf("%d starting block is already allocated \n",st);
printf("Do you want to enter more file(Yes - 1/No - 0)");
scanf("%d", &c);
if(c==1)
 goto x;
else
 exit(0);
getch();
}



/////////////////////////
Implement simple process management – parent and child, orphan, zombie, 
sleep (menu-driven C program is expected)

#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

void menu();
void zombie();
void orphan();
void parent_child();//inserting into the main function
int main()
{
menu();
return 0;
}
void menu()//creating the menu driven program
{
int ch;
printf("/n/n1. Zombie\n2. Orphan\n3. Parent Child\n4. Exit");
printf("\n\nEnter your choice : ");
scanf("%d",&ch);
if(ch==1)
zombie();
else if(ch==2)
orphan();
else if(ch==3)
parent_child();

else if (ch==4)
exit(0);
}
//the main processing command
void zombie()//processing the zombie
{
pid_t child_pid = Fork();
// Parent process
if (child_pid > 0)
{
sleep(50);
printf("Zombie completed");
}
// Child process
else
printf("Child Completed");
menu();
}
void orphan()//processing the orphan
{
// Create a child process
int pid = fork();

if (pid > 0)
printf("Parent Completed");
else if (pid == 0)
{
sleep(30);
printf("Child Completed");
}
menu();
}
void parent_child() //processing the child
{
int pid = fork();
if (pid > 0)
printf("Parent Completed");
else if (pid == 0)
printf("Child Completed");
menu();
}


/////////zombie processs
#include <stdlib.h> 
#include <sys/types.h> 
#include <unistd.h> 
int main() 
{ 
    // Fork returns process id 
    // in parent process 
    pid_t child_pid = fork(); 
  
    // Parent process  
    if (child_pid > 0) 
        sleep(50); 
  
    // Child process 
    else        
        exit(0); 
  
    return 0; 
} 


///orphan


// A C program to demonstrate Orphan Process.  
// Parent process finishes execution while the 
// child process is running. The child process 
// becomes orphan. 
#include<stdio.h> 
#include <sys/types.h> 
#include <unistd.h> 
  
int main() 
{ 
    // Create a child process       
    int pid = fork(); 
  
    if (pid > 0) 
        printf("in parent process"); 
  
    // Note that pid is 0 in child process 
    // and negative if fork() fails 
    else if (pid == 0) 
    { 
        sleep(30); 
        printf("in child process"); 
    } 
  
    return 0; 
} 

/////parent and child

#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>

int main()
{
    int pid;
    pid=fork();
    if(pid<0)
    {
        printf("\n Error ");
        exit(1);
    }
    else if(pid==0)
    {
        printf("\n Hello I am the child process ");
        printf("\n My pid is %d ",getpid());
        exit(0);
    }
    else
    {
        printf("\n Hello I am the parent process ");
        printf("\n My actual pid is %d \n ",getpid());
        exit(1);
    }

}

orr

#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
int main()
{
    int status;
    int pid;
    pid=fork();
    if(pid<0)
    {
        printf("\n Error ");
        exit(1);
    }
    else if(pid==0)
    {
        printf("\n Hello I am the child process ");
        printf("\n My pid is %d ",getpid());
        exit(0);
    }
    else
    {
       wait(&status);
        printf("\n Hello I am the parent process ");
        printf("\n My actual pid is %d \n ",getpid());
        exit(1);
    }

}









//////////////////////producer consumer
#include<stdio.h>
#include<stdlin.h>
int main()
{

int var=1;
int full=0;
int empty;
int x;
int m=;
int n;
 printf("enter the size of the buffer
 memory:");
scanf("%d",&m);
empty=m;
 printf("\n1.producer\n2.consumer.\n3.exit");
while(1){
	printf("\nEnter your choice");
	scanf("%d",&n);
	switch(n){

	case 1:
	      if((var==1) && (empty!=0))
{

		--var;
		++full;
--empty;
x++;
printf("\nproducer produces the item",x);
++var;


}
else 
printf("the buffer is full");
break;

case 2:
if((var==1) && (full!=0))
{
--var;
__full;
++empty;
printf("\nconsumer consumes the item",x);
x--;
++var;

}
else 
printf("Buffer is empty!!");
break
case 3:
exit(0);
break;
}


}
return 0;

}


#include<stdio.h>
int findLRU (int time[]. int n)
{

int i , minimum=time[0],pos = 0;
for(i=1;i<n;++i)
{
if(time[i] < minimum)
{
minimum = time[i];
pos = i;
}
}
return pos;

}

int main()
{
int no_of_frames, no_of_pages, frames[10],pages[30],counter=0,time[10],flag1,flag2,i,j,pos,faults=0;
printf("ENter number of frames :");
scanf("%d",&no_of_frames);


printf("Enter number of pages");
scanf("%d",&no_of_pages);

printf("ENter reference string:");
for(i=0;i<no_of_pages;i++)
{
scanf("%d",&pages[i]);
}

for(i=0;i<no_of_frames;i++)
{
frames[i]= -1;
}

//////////////reader and writer


sem_t mutex, writeblock;
int data= 0,rcount=0;


void*reader(void * arg)
{
int f;
f=((int)arg);
sem_wait(&mutex);
rcount = rcount + 1;
if(rcount==1)
sem_wait(&writeblock);
sem_post(&mutex)
printf("data read by the reader%d is


pthread_mutex_t x,wsem;
pthread_t tid;
int readcount;

void initialize()
{
pthread_mutex_init(&x,NULL);
pthread_mutex_init(&wsem,NULL);
readcount=0;

}
void * reader (void * param)
{
int waittime;
waittime = rand() %  5;
printf("\nReader is trying to enter");
pthread_mutex_lock(&x);
readcount++;
if(readcount==1)
pthread_mutex_lock(&wsem);
printf("\n%d reader is inside",readcount);
pthread_mutex_unlock(&x);
Sleep(waittime);
pthread_mutex_lock(&x);
readcount--;
if(readcount==0)
pthread_mutex_unlock(&wsem);
pthread_mutex_unlock(&x);
printf("\nReader is leaving");
}


void * writer (void * param)
{
int waittime;
waittime=rand() % 3;
printf("\nwriter is trying to enter");
pthread_mutex_lock(&wsem);
printf("\nwrite has entered");
Sleep(30);
exit(0);
}

int main()
{
int n1,n2,i;
printf("\nEnter the no of readers:");
scanf("%d",&n1);
printf("\nEnter the no of writers:");
scanf("%d",&n2);

for(i=0;i<n1;i++)
pthread_create





//Basic Disk Scheduling
#include<stdio.h>
#include<conio.h>
#include<math.h>

void fcfs(int a[]);
void sstf(int a[]);
void scan(int a[]);



void main()
{
int n, a[10], ch, i;
printf("enter 10 cylinders numbers");
for(i=0; i<10; i++)
{
scanf("%d", &a[i]);
}



run:
{


printf("\n\n which algo do u want to use?");
printf("\n1) FCFS\n2)SSTF\n3)SCAN\n4)EXIT\n");
scanf("%d", &ch);

switch(ch)
{


      case 1: fcfs(a);
	      goto run;

      case 2: sstf(a);
	      goto run;

      case 3: scan(a);
	      goto run;

      case 4: exit(0);

      default: printf("please enter a valid choice");
	       goto run;

      }
      }
getch();
}

void fcfs(int a[])
{
int order[10], i, x, count=0, ptr;

printf("\n current pointer location");
scanf("%d", &ptr);
for(i=0; i<10; i++)
{
order[i] = a[i];
}
x= ptr- a[0];
if(x>0)
count=x;
else
count= -x;


for(i=1; i<10; i++)
{
x= a[i] - a[i-1];
if(x<0)
count =count+ (-x);
else
count =count+  x;
}

printf("Execution order:\n");
for(i=0; i<10; i++)
{
printf("%d ", order[i]);
}

printf("\nTotal cost : %d", count);
}


void sstf(int a[])
{
int i, j, ptr, count, x, m=9, b[10], min=9999, temp;
printf("\n current pointer location");
scanf("%d", &ptr);
j=ptr;
for(i=0; i<10; i++)
{
b[i] =a[i];
}

while(m>=0)
{
min=9999;
i=m;
while(i>=0)
{
if(abs(b[i]-ptr)<min)
{
min= abs(b[i]-ptr);
x=i;

}
--i;
}
ptr=a[x];
temp= b[x];
b[x] = b[m];
b[m] = temp;
--m;
}

count = abs(j-b[9]);
printf("execution order:\n");
for(i=9; i>=1; i--)
{
printf("%d ", b[i]);
count =count+ abs(b[i]-b[i-1]);
}
printf("%d ", b[0]);
printf("\nTotal cost : %d", count);



}


void scan(int a[])
{
  int ptr, b[11], i, j, min, x, temp;
 printf("\n current pointer location");
scanf("%d", &ptr);
b[0]= ptr;
for(i=0; i<10; i++)
{
b[i+1]= a[i];
}

for(i=0; i<10; i++)
{
min= i;
for(j=i+1; j<11; j++)
{
if(b[j]<b[min])
{
min = j;
}
}
temp = b[i];
b[i] = b[min];
b[min] = temp;
}


i=0;
while(b[i]!=ptr && i<11)
{
i++;
}
printf("\nExecution order :");
x=i;
i=x+1;
while(i!=x)
{
printf(" %d", b[i]);
i= (i+1)%11;
}


}






///////////////barber and sleeping

#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 

#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 
#include <pthread.h> 
#include <semaphore.h> // The maximum number of customer threads. 
#define MAX_CUSTOMERS 25 // Function prototypes...

void *customer(void *num); 
void *barber(void *); 
void randwait(int secs); 



//Define the semaphores. 
// waitingRoom Limits the # of customers allowed  to enter the waiting room at one time.
sem_t waitingRoom; 
// barberChair ensures mutually exclusive access to the barber chair.
sem_t barberChair; 
// barberPillow is used to allow the barber to sleep until a customer arrives.
sem_t barberPillow; 
// seatBelt is used to make the customer to wait until the barber is done cutting his/her hair. 
sem_t seatBelt;
// Flag to stop the barber thread when all customers have been serviced.
int allDone = 0; 

int main(int argc, char *argv[]) 
{
    pthread_t btid; 
    pthread_t tid[MAX_CUSTOMERS]; 
    int i, x, numCustomers, numChairs; int Number[MAX_CUSTOMERS]; 
    printf("Maximum number of customers can only be 25. Enter number of customers and chairs.\n");
    scanf("%d",&x);
    numCustomers = x; 
    scanf("%d",&x);
    numChairs = x;
    if (numCustomers > MAX_CUSTOMERS) { 
       printf("The maximum number of Customers is %d.\n", MAX_CUSTOMERS); 
       system("PAUSE");    
       return 0;
    } 
    printf("A solution to the sleeping barber problem using semaphores.\n"); 
    for (i = 0; i < MAX_CUSTOMERS; i++) { 
        Number[i] = i; 
    } 
    // Initialize the semaphores with initial values... 
    sem_init(&waitingRoom, 0, numChairs); 
    sem_init(&barberChair, 0, 1);
    sem_init(&barberPillow, 0, 0); 
    sem_init(&seatBelt, 0, 0); 
    
    // Create the barber. 
    pthread_create(&btid, NULL, barber, NULL); 
    
    // Create the customers. 
    for (i = 0; i < numCustomers; i++) {
        pthread_create(&tid[i], NULL, customer, (void *)&Number[i]); 
    } 
    // Join each of the threads to wait for them to finish. 
    for (i = 0; i < numCustomers; i++) { 
        pthread_join(tid[i],NULL); 
    } 
    // When all of the customers are finished, kill the barber thread. 
    allDone = 1; 
    sem_post(&barberPillow); // Wake the barber so he will exit. 
    pthread_join(btid,NULL); 
    system("PAUSE");    


    
    
} 




int menu()

{
	int ch,semaphore,customers,barbers,barber,mutex,waiting,cut_hair,chairs,true;
	printf("\n\nMENU\n");
	printf("\n1.customers\n2.barbers\n3.randwait\n4.exit");
	scanf("%d",&ch);
	if(ch==1){
		
		void *customer(void *number) { 
     int num = *(int *)number; // Leave for the shop and take some random amount of  time to arrive. 
     printf("Customer %d leaving for barber shop.\n", num); 
     randwait(5); 
     printf("Customer %d arrived at barber shop.\n", num); // Wait for space to open up in the waiting room... 
     sem_wait(&waitingRoom); 
     printf("Customer %d entering waiting room.\n", num); // Wait for the barber chair to become free. 
     sem_wait(&barberChair); // The chair is free so give up your spot in the  waiting room. 
     sem_post(&waitingRoom); // Wake up the barber... 
     printf("Customer %d waking the barber.\n", num); 
     sem_post(&barberPillow); // Wait for the barber to finish cutting your hair. 
     sem_wait(&seatBelt); // Give up the chair. 
     sem_post(&barberChair); 
     printf("Customer %d leaving barber shop.\n", num); 
}
	}
	
	
	if(ch==2)
	{
		
		
		void *barber(void *junk) 
{ 
// While there are still customers to be serviced... Our barber is omnicient and can tell if there are  customers still on the way to his shop. 
   
  while (!allDone) 
  { 
  // Sleep until someone arrives and wakes you.. 
    printf("The barber is sleeping\n"); 
    sem_wait(&barberPillow); // Skip this stuff at the end... 
    if (!allDone) 
    { // Take a random amount of time to cut the customer's hair.
     printf("The barber is cutting hair\n"); 
     randwait(3);
     printf("The barber has finished cutting hair.\n"); // Release the customer when done cutting... 
     sem_post(&seatBelt); 
    } 
    else { 
         printf("The barber is going home for the day.\n"); 
    } 
   }
	}
	
	
	if(ch==3)
	{
		void randwait(int secs) 
		{ 
     int len = 1; // Generate an arbit number...
     sleep(len); 



	}
	
		

	
}

getch();
}
}


//////////////derived one for barber and sleeping


#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 

#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 
#include <pthread.h> 
#include <semaphore.h> // The maximum number of customer threads. 
#define MAX_CUSTOMERS 25 // Function prototypes...

void *customer(void *num); 
void *barber(void *); 
void randwait(int secs); 

//Define the semaphores. 
// waitingRoom Limits the # of customers allowed  to enter the waiting room at one time.
sem_t waitingRoom; 
// barberChair ensures mutually exclusive access to the barber chair.
sem_t barberChair; 
// barberPillow is used to allow the barber to sleep until a customer arrives.
sem_t barberPillow; 
// seatBelt is used to make the customer to wait until the barber is done cutting his/her hair. 
sem_t seatBelt;
// Flag to stop the barber thread when all customers have been serviced.
int allDone = 0; 

int main(int argc, char *argv[]) 
{
    pthread_t btid; 
    pthread_t tid[MAX_CUSTOMERS]; 
    int i, x, numCustomers, numChairs; int Number[MAX_CUSTOMERS]; 
    printf("Maximum number of customers can only be 25. Enter number of customers and chairs.\n");
    scanf("%d",&x);
    numCustomers = x; 
    scanf("%d",&x);
    numChairs = x;
    if (numCustomers > MAX_CUSTOMERS) { 
       printf("The maximum number of Customers is %d.\n", MAX_CUSTOMERS); 
       system("PAUSE");    
       return 0;
    } 
    printf("A solution to the sleeping barber problem using semaphores.\n"); 
    for (i = 0; i < MAX_CUSTOMERS; i++) { 
        Number[i] = i; 
    } 
    // Initialize the semaphores with initial values... 
    sem_init(&waitingRoom, 0, numChairs); 
    sem_init(&barberChair, 0, 1);
    sem_init(&barberPillow, 0, 0); 
    sem_init(&seatBelt, 0, 0); 
    
    // Create the barber. 
    pthread_create(&btid, NULL, barber, NULL); 
    
    // Create the customers. 
    for (i = 0; i < numCustomers; i++) {
        pthread_create(&tid[i], NULL, customer, (void *)&Number[i]); 
    } 
    // Join each of the threads to wait for them to finish. 
    for (i = 0; i < numCustomers; i++) { 
        pthread_join(tid[i],NULL); 
    } 
    // When all of the customers are finished, kill the barber thread. 
    allDone = 1; 
    sem_post(&barberPillow); // Wake the barber so he will exit. 
    pthread_join(btid,NULL); 
    system("PAUSE");    
    return 0;
} 

void *customer(void *number) { 
     int num = *(int *)number; // Leave for the shop and take some random amount of  time to arrive. 
     printf("Customer %d leaving for barber shop.\n", num); 
     randwait(5); 
     printf("Customer %d arrived at barber shop.\n", num); // Wait for space to open up in the waiting room... 
     sem_wait(&waitingRoom); 
     printf("Customer %d entering waiting room.\n", num); // Wait for the barber chair to become free. 
     sem_wait(&barberChair); // The chair is free so give up your spot in the  waiting room. 
     sem_post(&waitingRoom); // Wake up the barber... 
     printf("Customer %d waking the barber.\n", num); 
     sem_post(&barberPillow); // Wait for the barber to finish cutting your hair. 
     sem_wait(&seatBelt); // Give up the chair. 
     sem_post(&barberChair); 
     printf("Customer %d leaving barber shop.\n", num); 
} 

void *barber(void *junk) 
{ 
// While there are still customers to be serviced... Our barber is omnicient and can tell if there are  customers still on the way to his shop. 
   
  while (!allDone) { // Sleep until someone arrives and wakes you.. 
    printf("The barber is sleeping\n"); 
    sem_wait(&barberPillow); // Skip this stuff at the end... 
    if (!allDone) 
    { // Take a random amount of time to cut the customer's hair.
     printf("The barber is cutting hair\n"); 
     randwait(3);
     printf("The barber has finished cutting hair.\n"); // Release the customer when done cutting... 
     sem_post(&seatBelt); 
    } 
    else { 
         printf("The barber is going home for the day.\n"); 
    } 
   }
}
    
void randwait(int secs) { 
     int len = 1; // Generate an arbit number...
     sleep(len); 
}




/////////////////////lru cache
// A C program to show implementation of LRU cache 
#include <stdio.h> 
#include <stdlib.h> 
  
// A Queue Node (Queue is implemented using Doubly Linked List) 
typedef struct QNode 
{ 
    struct QNode *prev, *next; 
    unsigned pageNumber;  // the page number stored in this QNode 
} QNode; 
  
// A Queue (A FIFO collection of Queue Nodes) 
typedef struct Queue 
{ 
    unsigned count;  // Number of filled frames 
    unsigned numberOfFrames; // total number of frames 
    QNode *front, *rear; 
} Queue; 
  
// A hash (Collection of pointers to Queue Nodes) 
typedef struct Hash 
{ 
    int capacity; // how many pages can be there 
    QNode* *array; // an array of queue nodes 
} Hash; 
  
// A utility function to create a new Queue Node. The queue Node 
// will store the given 'pageNumber' 
QNode* newQNode( unsigned pageNumber ) 
{ 
    // Allocate memory and assign 'pageNumber' 
    QNode* temp = (QNode *)malloc( sizeof( QNode ) ); 
    temp->pageNumber = pageNumber; 
  
    // Initialize prev and next as NULL 
    temp->prev = temp->next = NULL; 
  
    return temp; 
} 
  
// A utility function to create an empty Queue. 
// The queue can have at most 'numberOfFrames' nodes 
Queue* createQueue( int numberOfFrames ) 
{ 
    Queue* queue = (Queue *)malloc( sizeof( Queue ) ); 
  
    // The queue is empty 
    queue->count = 0; 
    queue->front = queue->rear = NULL; 
  
    // Number of frames that can be stored in memory 
    queue->numberOfFrames = numberOfFrames; 
  
    return queue; 
} 
  
// A utility function to create an empty Hash of given capacity 
Hash* createHash( int capacity ) 
{ 
    // Allocate memory for hash 
    Hash* hash = (Hash *) malloc( sizeof( Hash ) ); 
    hash->capacity = capacity; 
  
    // Create an array of pointers for refering queue nodes 
    hash->array = (QNode **) malloc( hash->capacity * sizeof( QNode* ) ); 
  
    // Initialize all hash entries as empty 
    int i; 
    for( i = 0; i < hash->capacity; ++i ) 
        hash->array[i] = NULL; 
  
    return hash; 
} 
  
// A function to check if there is slot available in memory 
int AreAllFramesFull( Queue* queue ) 
{ 
    return queue->count == queue->numberOfFrames; 
} 
  
// A utility function to check if queue is empty 
int isQueueEmpty( Queue* queue ) 
{ 
    return queue->rear == NULL; 
} 
  
// A utility function to delete a frame from queue 
void deQueue( Queue* queue ) 
{ 
    if( isQueueEmpty( queue ) ) 
        return; 
  
    // If this is the only node in list, then change front 
    if (queue->front == queue->rear) 
        queue->front = NULL; 
  
    // Change rear and remove the previous rear 
    QNode* temp = queue->rear; 
    queue->rear = queue->rear->prev; 
  
    if (queue->rear) 
        queue->rear->next = NULL; 
  
    free( temp ); 
  
    // decrement the number of full frames by 1 
    queue->count--; 
} 
  
// A function to add a page with given 'pageNumber' to both queue 
// and hash 
void Enqueue( Queue* queue, Hash* hash, unsigned pageNumber ) 
{ 
    // If all frames are full, remove the page at the rear 
    if ( AreAllFramesFull ( queue ) ) 
    { 
        // remove page from hash 
        hash->array[ queue->rear->pageNumber ] = NULL; 
        deQueue( queue ); 
    } 
  
    // Create a new node with given page number, 
    // And add the new node to the front of queue 
    QNode* temp = newQNode( pageNumber ); 
    temp->next = queue->front; 
  
    // If queue is empty, change both front and rear pointers 
    if ( isQueueEmpty( queue ) ) 
        queue->rear = queue->front = temp; 
    else  // Else change the front 
    { 
        queue->front->prev = temp; 
        queue->front = temp; 
    } 
  
    // Add page entry to hash also 
    hash->array[ pageNumber ] = temp; 
  
    // increment number of full frames 
    queue->count++; 
} 
  
// This function is called when a page with given 'pageNumber' is referenced 
// from cache (or memory). There are two cases: 
// 1. Frame is not there in memory, we bring it in memory and add to the front 
//    of queue 
// 2. Frame is there in memory, we move the frame to front of queue 
void ReferencePage( Queue* queue, Hash* hash, unsigned pageNumber ) 
{ 
    QNode* reqPage = hash->array[ pageNumber ]; 
  
    // the page is not in cache, bring it 
    if ( reqPage == NULL ) 
        Enqueue( queue, hash, pageNumber ); 
  
    // page is there and not at front, change pointer 
    else if (reqPage != queue->front) 
    { 
        // Unlink rquested page from its current location 
        // in queue. 
        reqPage->prev->next = reqPage->next; 
        if (reqPage->next) 
           reqPage->next->prev = reqPage->prev; 
  
        // If the requested page is rear, then change rear 
        // as this node will be moved to front 
        if (reqPage == queue->rear) 
        { 
           queue->rear = reqPage->prev; 
           queue->rear->next = NULL; 
        } 
  
        // Put the requested page before current front 
        reqPage->next = queue->front; 
        reqPage->prev = NULL; 
  
        // Change prev of current front 
        reqPage->next->prev = reqPage; 
  
        // Change front to the requested page 
        queue->front = reqPage; 
    } 
} 
  
// Driver program to test above functions 
int main() 
{ 
    // Let cache can hold 4 pages 
    Queue* q = createQueue( 4 ); 
  
    // Let 10 different pages can be requested (pages to be 
    // referenced are numbered from 0 to 9 
    Hash* hash = createHash( 10 ); 
  
    // Let us refer pages 1, 2, 3, 1, 4, 5 
    ReferencePage( q, hash, 1); 
    ReferencePage( q, hash, 2); 
    ReferencePage( q, hash, 3); 
    ReferencePage( q, hash, 1); 
    ReferencePage( q, hash, 4); 
    ReferencePage( q, hash, 5); 
  
    // Let us print cache frames after the above referenced pages 
    printf ("%d ", q->front->pageNumber); 
    printf ("%d ", q->front->next->pageNumber); 
    printf ("%d ", q->front->next->next->pageNumber); 
    printf ("%d ", q->front->next->next->next->pageNumber); 
  
    return 0; 
}


	

///////////////
#include <stdio.h>
#include <stdlib.h>
 

typedef struct QNode
{
    struct QNode *prev, *next;
    unsigned pageNumber;  
} QNode;
 
typedef struct Queue
{
    unsigned count;  
    unsigned numberOfFrames; 
    QNode *front, *rear;
} Queue;
 
typedef struct Hash
{
    int capacity; 
    QNode* *array;
} Hash;
 
QNode* newQNode( unsigned pageNumber )
{
    QNode* temp = (QNode *)malloc( sizeof( QNode ) );
    temp->pageNumber = pageNumber;
    temp->prev = temp->next = NULL;
    return temp;
}
 
Queue* createQueue( int numberOfFrames )
{
    Queue* queue = (Queue *)malloc( sizeof( Queue ) ); 
    queue->count = 0;
    queue->front = queue->rear = NULL;
    queue->numberOfFrames = numberOfFrames;
 
    return queue;
}
 

Hash* createHash( int capacity )
{
    Hash* hash = (Hash *) malloc( sizeof( Hash ) );
    hash->capacity = capacity;
    hash->array = (QNode **) malloc( hash->capacity * sizeof( QNode* ) );
    int i;
    for( i = 0; i < hash->capacity; ++i )
        hash->array[i] = NULL;
 
    return hash;
}
 
int AreAllFramesFull( Queue* queue )
{
    return queue->count == queue->numberOfFrames;
}
 

int isQueueEmpty( Queue* queue )
{
    return queue->rear == NULL;
}
 
void deQueue( Queue* queue )
{
    if( isQueueEmpty( queue ) )
        return;
 
    if (queue->front == queue->rear)
        queue->front = NULL;
 
    QNode* temp = queue->rear;
    queue->rear = queue->rear->prev;
 
    if (queue->rear)
        queue->rear->next = NULL;
 
    free( temp );

    queue->count--;
}
 
void Enqueue( Queue* queue, Hash* hash, unsigned pageNumber )
{

    if ( AreAllFramesFull ( queue ) )
    {
        hash->array[ queue->rear->pageNumber ] = NULL;
        deQueue( queue );
    }
 
    QNode* temp = newQNode( pageNumber );
    temp->next = queue->front;
 
    if ( isQueueEmpty( queue ) )
        queue->rear = queue->front = temp;
    else 
    {
        queue->front->prev = temp;
        queue->front = temp;
    }
 
    hash->array[ pageNumber ] = temp;
 
 
    queue->count++;
}
 

void ReferencePage( Queue* queue, Hash* hash, unsigned pageNumber )
{
    QNode* reqPage = hash->array[ pageNumber ];
 
    if ( reqPage == NULL )
        Enqueue( queue, hash, pageNumber );
 
    else if (reqPage != queue->front)
    {
        reqPage->prev->next = reqPage->next;
        if (reqPage->next)
           reqPage->next->prev = reqPage->prev;
         if (reqPage == queue->rear)
        {
           queue->rear = reqPage->prev;
           queue->rear->next = NULL;
        }
        reqPage->next = queue->front;
        reqPage->prev = NULL;
        reqPage->next->prev = reqPage;
 
        queue->front = reqPage;
    }
}
 

int main()
{
   
    Queue* q = createQueue( 4 );        
    Hash* hash = createHash( 10 );
    ReferencePage( q, hash, 1);
    ReferencePage( q, hash, 2);
    ReferencePage( q, hash, 3);
    ReferencePage( q, hash, 1);
    ReferencePage( q, hash, 4);
    ReferencePage( q, hash, 5);
    printf ("%d ", q->front->pageNumber);
    printf ("%d ", q->front->next->pageNumber);
    printf ("%d ", q->front->next->next->pageNumber);
    printf ("%d ", q->front->next->next->next->pageNumber);
 
    return 0;
}








/////////////////////////////////
#include <bits/stdc++.h>
using namespace std;

struct Process {
	int p; // Process ID
	int bt; // Burst Time
	int at; // Arrival Time
	int rt; // Remaining Burst Time
	int wt; // Waiting Time
	int tat; //Turn Around Time
}p[20], temp, org[20];

struct comp{
	char algo[20];
	float avg_wt;
	float avg_tat;
}algo[20];


void menu();
void input();
void assign();
void comparator();

void fcfs(int);
void sjf(int);
void rr(int);
void srtf(int);
void irr(int);
void irr_mean_tq(int);
void irr_min_tq(int);
void irrsjf(int);
void irrsjfdtq(int);


int n;

int main()
{
	cout<<"###############################  WELCOME TO OS PROJECT  ###############################\n\n";
	menu();
	return 0;
}


void menu()
{
	int ch;
	printf("\n\nTable\n\n1.New Input\n2.FCFS Algorithm\n3.RR Algorithm\n4.IRR Algorithm\n5.IRR_MEAN_TQ  Algorithm\n6.IRR_MIN_TQ  Algorithm\n7.IRR_SJF  Algorithm\n8.IRR_SJF_DTQ  Algorithm\n9.Compare All\n10.Exit");
	printf("\n\nEnter your choice from the above table : ");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:input();break;
			case 2:fcfs(1);break;
			case 3:rr(1);break;
			case 4:irr(1);break;
			case 5:irr_mean_tq(1);break;
			case 6:irr_min_tq(1);break;
			case 7:irrsjf(1);break;
			case 8:irrsjfdtq(1);break;
			case 9:comparator();break;
			case 10:exit(0);break;
			default: printf("\n\nPlease enter choice from 1 to 10 only\n");menu();
		}
}


void input()
{
	cout<<"\nEnter Number of processes : ";
	cin>>n;
		
	cout<<"\n\nEnter the Burst Time of the Processes : \n"; 
	for(int i=0;i<n;i++)
	{
		cout<<"Process "<<i+1<<" : ";
		cin>>org[i].bt;
		org[i].rt=org[i].bt;
	}
	
	cout<<"\n\nEnter the Arrival Time of the Processes : \n";
	
	for(int i=0; i<n; i++)
	{
		cout<<"Process "<<i+1<<" : ";
		cin>>org[i].at;
		org[i].p=i+1;
	}
	menu();
}

sort_at()
{
	for(int i=0; i<n-1; i++)
	{
		for(int j=0; j<n-i-1; j++)
		{
			if(p[j].at>p[j+1].at)
			{
				temp=p[j];
				p[j]=p[j+1];
				p[j+1]=temp;
			}
		}
	}
}

void assign()
{
	for(int i=0; i<n; i++)
		p[i]=org[i];
}

void fcfs(int menu_flag)
{
	cout<<"\n\n\n#############  First Come First Serve  #############\n\n\n";
	assign();
	sort_at();
	int sum=0, tot_tat=0, tot_wt=0;
	for(int i=0; i<n; i++)
	{
		p[i].wt=sum-p[i].at;
		if(p[i].wt<0)
			p[i].wt=0;
		p[i].tat=p[i].bt+p[i].wt;
		sum+=p[i].bt;
		tot_tat+=p[i].tat;
		tot_wt+=p[i].wt;
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n";
	strcpy(algo[0].algo,"fcfs");
	algo[0].avg_tat=(float)tot_tat/n;
	algo[0].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}

void srtf(int menu_flag)
{
	cout<<"\n\n\n#############  Shortest Remaining Time First  #############\n\n\n";
	assign(); 
	int tot_wt=0, tot_tat=0;  
  
    int complete = 0, t = 0, minm = INT_MAX; 
    int shortest = 0, finish_time; 
    bool check = false; 
  
    // Process until all processes gets completed 
    while (complete != n) { 
  
        // Find process with minimum 
        // remaining time among the 
        // processes that arrives till the 
        // current time` 
        for (int j = 0; j < n; j++) { 
            if ((p[j].at <= t) && (p[j].rt < minm) && p[j].rt > 0) 
			{ 
                minm = p[j].rt; 
                shortest = j; 
                check = true; 
            } 
        } 
  
        if (check == false) 
		{ 
            t++; 
            continue; 
        } 
  
        // Reduce remaining time by one 
        p[shortest].rt--; 
  
        // Update minimum 
        minm = p[shortest].rt; 
        if (minm == 0) 
            minm = INT_MAX; 
  
        // If a process gets completely 
        // executed 
        if (p[shortest].rt == 0) { 
  
            // Increment complete 
            complete++; 
  
            // Find finish time of current 
            // process 
            finish_time = t + 1; 
  
            // Calculate waiting time 
            p[shortest].wt = finish_time - p[shortest].bt - p[shortest].at; 
  			
            if (p[shortest].wt < 0) 
                p[shortest].wt = 0; 
        } 
        // Increment time 
        t++; 
    }
	
	for(int i=0; i<n; i++)
	{
		p[i].tat=p[i].bt+p[i].wt;
		tot_wt+=p[i].wt;
		tot_tat+=p[i].tat;
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[8].algo,"srtf");
	algo[8].avg_tat=(float)tot_tat/n;
	algo[8].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}

void sjf(int menu_flag)
{
	cout<<"\n\n\n#############  Shortest Job First  #############\n\n\n";
	assign();
	sort_at();
	int tot_wt=0, tot_tat=0,sum=0, btime=0, k=1, min;
	for(int j=0;j<n;j++)
	{
		btime=btime+p[j].bt;
		min=p[k].bt;
		for(int i=k;i<n;i++)
		{
			if (btime>=p[i].at && p[i].bt<min)
			{
				temp=p[k];
				p[k]=p[i];
				p[i]=temp;
			}
		}
		k++;
	}
	
	p[0].wt=0;
	for(int i=1;i<n;i++)
	{
		sum+=p[i-1].bt;
		p[i].wt=sum-p[i].at;
		tot_wt+=p[i].wt;
		p[i].tat=p[i].bt+p[i].wt;
		tot_tat+=p[i].tat;
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[7].algo,"sjf");
	algo[7].avg_tat=(float)tot_tat/n;
	algo[7].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}
 
void rr(int menu_flag) 
{ 
	cout<<"\n\n\n#############  Round Robin  #############\n\n\n";
	assign();
  int remain=n, time_quantum, tot_wt=0, tot_tat=0, flag=0; 
  sort_at();
  cout<<"\nEnter Time Quantum : "; 
  cin>>time_quantum;  
  for(int i=0,time=0; remain!=0;) 
  { 
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[1].algo,"rr");
	algo[1].avg_tat=(float)tot_tat/n;
	algo[1].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}


void irr(int menu_flag) 
{ 
	cout<<"\n\n#############  Improved Round Robin  #############\n\n";
	assign();
  int remain=n, rt[n], time_quantum, tot_wt=0, tot_tat=0, flag=0; 
  sort_at();
  for(int i=0; i<n; i++)  
    rt[p[i].p-1]=p[p[i].p-1].bt;
  cout<<"\nEnter Time Quantum : "; 
  cin>>time_quantum;  
  for(int i=0,time=0; remain!=0;) 
  { 
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[2].algo,"irr");
	algo[2].avg_tat=(float)tot_tat/n;
	algo[2].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}

void irr_mean_tq(int menu_flag) 
{ 
	cout<<"\n\n#############  Improved Roud Robin with Mean Quantum Time  #############\n\n";
	assign();
  int remain=n, rt[n], time_quantum, tot_wt=0, tot_tat=0, flag=0, mean=0; 
  sort_at();
  for(int i=0; i<n; i++)  
    rt[p[i].p-1]=p[p[i].p-1].bt;  
  for(int i=0,time=0; remain!=0;) 
  { 
	mean=0;
  	for(int j=0; j<n; j++)
	  	mean+=p[j].rt;
	time_quantum = (mean/remain + 1) / 2;	
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    }
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[3].algo,"irr_mean_tq");
	algo[3].avg_tat=(float)tot_tat/n;
	algo[3].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();

}

void irr_min_tq(int menu_flag) 
{ 
	cout<<"\n\n#############  Improved ROund Robin with Min Quantum Time  #############\n\n";
	assign();
  int remain=n, rt[n], time_quantum, tot_wt=0, tot_tat=0, flag=0, mintq=1000; 
  sort_at();
  for(int i=0; i<n; i++)  
    rt[p[i].p-1]=p[p[i].p-1].bt;  
  for(int i=0,time=0; remain!=0;) 
  { 
  	mintq=1000;
  	for(int j=0; j<n; j++)
	  	if(mintq>p[j].rt and p[j].rt!=0)
	  		mintq=p[j].rt;
	time_quantum = mintq;	
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    }
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[4].algo,"irr_min_tq");
	algo[4].avg_tat=(float)tot_tat/n;
	algo[4].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}

void irrsjf(int menu_flag)
{
	cout<<"\n\n#############  Imporved Roubd Robin Shortest Job First  #############\n\n";
    int time_quantum,tot_tat=0, tot_wt=0;
    int remain=n;
    int time=0; 
	int old_mean=0;
    
    cout<<"\nEnter Time Quantum : "; 
	cin>>time_quantum;
    
    for(int i=0; i<n; i++)
		p[i].rt=p[i].bt;
	while(remain>0)
	{	
		//sorting in ascending order
		for(int i=0;i<n;i++)
			for(int j=0;j<n-i-1;j++)
				if(p[j].rt>p[j+1].rt)
				{
					temp=p[j+1];
					p[j+1]=p[j];
					p[j]=temp;
				}	
		for(int i=0;i<n;i++) //loop main
		{
			if(p[i].at<=time && p[i].rt!=0)
    		{
        		if(p[i].rt<time_quantum && p[i].rt!=0)
    			{
			        time+=p[i].rt;
			        p[i].rt=0;
    			}
        		else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
			    { 
			      time+=p[i].rt; 
			      p[i].rt=0;  
			    }
				else
   		 		{
			        time+=time_quantum;
			        p[i].rt-=time_quantum;
    			}
        		
				if(p[i].rt==0)
    			{
			        p[i].wt=time-p[i].bt-p[i].at;
			        p[i].tat=time-p[i].at;
					remain--;
    			}
    		}
		}
	}
	for(int i=0; i<n; i++)
	{
		tot_wt += p[i].wt;
		tot_tat += p[i].tat; 
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[5].algo,"irr_sjf");
	algo[5].avg_tat=(float)tot_tat/n;
	algo[5].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}



void irrsjfdtq(int menu_flag)
{
	cout<<"\n\n#############  Improved Round Robin Shortest Job First with Dynamic Quantum Time  #############\n\n";
    int time_quantum,tot_tat=0, tot_wt=0;
    int remain=n;
    int time=0;
    int max_bt;
    int sum_bt,prq;  // prq = process in ready queue
	int old_mean=0;
    
    for(int i=0; i<n; i++)
    {	
		p[i].rt=p[i].bt;
		old_mean+=p[i].bt;
	}
	old_mean/=n;
	while(remain>0)
	{
		//sorting in ascending order
		for(int i=0;i<n;i++)
			for(int j=0;j<n-i-1;j++)
				if(p[j].rt>p[j+1].rt)
				{
					temp=p[j+1];
					p[j+1]=p[j];
					p[j]=temp;
				}	
		for(int i=0;i<n;i++) //loop main
		{
			prq=0;  
        	max_bt=0;
        	sum_bt=0;
    		for(int j=0;j<n;j++)
	    	{
				if(p[j].at<=time && p[j].rt!=0)
				{
	        		prq++;
	        		if(p[j].rt>max_bt)
	            		max_bt=p[j].rt;
	        		sum_bt+=p[j].rt;
	    		}
	    	}
	    	
			if(prq==0 ||  (sum_bt/prq) == 0)
	    		time_quantum = old_mean;
	    	else
	    	{
				time_quantum=sum_bt/prq;
				old_mean = time_quantum;
			}
			if(p[i].at<=time && p[i].rt!=0)
    		{
        		if(p[i].rt<time_quantum && p[i].rt!=0)
    			{
			        time+=p[i].rt;
			        p[i].rt=0;
    			}
        		else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
			    { 
			      time+=p[i].rt; 
			      p[i].rt=0;  
			    }
				else
   		 		{
			        time+=time_quantum;
			        p[i].rt-=time_quantum;
    			}
        		
				if(p[i].rt==0)
    			{
			        p[i].wt=time-p[i].bt-p[i].at;
			        p[i].tat=time-p[i].at;
					remain--;
    			}
    		}
		}
	}
	for(int i=0; i<n; i++)
	{
		tot_wt += p[i].wt;
		tot_tat += p[i].tat; 
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[6].algo,"irr_sjf_dtq");
	algo[6].avg_tat=(float)tot_tat/n;
	algo[6].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}


void comparator()
{
	fcfs(0);
	sjf(0);
	rr(0);
	irr(0);
	irr_mean_tq(0);
	irr_min_tq(0);
	irrsjf(0);
	irrsjfdtq(0);
	srtf(0);
	cout<<"\n\n#############  Comparing All  #############\n\n";
	cout<<"\n\n Algorithm\t\tAVG_WT\t\tAVG_TAT\n\n";
	for(int i=0; i<7; i++)
		if(strlen(algo[i].algo)>4)
			cout<<"   "<<algo[i].algo<<"\t\t"<<algo[i].avg_wt<<"\t\t"<<algo[i].avg_tat<<"\n";
		else	
			cout<<"   "<<algo[i].algo<<"\t\t\t"<<algo[i].avg_wt<<"\t\t"<<algo[i].avg_tat<<"\n";
	menu();
}




///////////////////////////////
void sjf(int menu_flag)
{
	cout<<"\n\n\n#############  Shortest Job First  #############\n\n\n";
	assign();
	sort_at();
	int tot_wt=0, tot_tat=0,sum=0, btime=0, k=1, min;
	for(int j=0;j<n;j++)
	{
		btime=btime+p[j].bt;
		min=p[k].bt;
		for(int i=k;i<n;i++)
		{
			if (btime>=p[i].at && p[i].bt<min)
			{
				temp=p[k];
				p[k]=p[i];
				p[i]=temp;
			}
		}
		k++;
	}
	
	p[0].wt=0;
	for(int i=1;i<n;i++)
	{
		sum+=p[i-1].bt;
		p[i].wt=sum-p[i].at;
		tot_wt+=p[i].wt;
		p[i].tat=p[i].bt+p[i].wt;
		tot_tat+=p[i].tat;
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[7].algo,"sjf");
	algo[7].avg_tat=(float)tot_tat/n;
	algo[7].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}
 
void rr(int menu_flag) 
{ 
	cout<<"\n\n\n#############  Round Robin  #############\n\n\n";
	assign();
  int remain=n, time_quantum, tot_wt=0, tot_tat=0, flag=0; 
  sort_at();
  cout<<"\nEnter Time Quantum : "; 
  cin>>time_quantum;  
  for(int i=0,time=0; remain!=0;) 
  { 
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[1].algo,"rr");
	algo[1].avg_tat=(float)tot_tat/n;
	algo[1].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}


void irr(int menu_flag) 
{ 
	cout<<"\n\n#############  Improved Round Robin  #############\n\n";
	assign();
  int remain=n, rt[n], time_quantum, tot_wt=0, tot_tat=0, flag=0; 
  sort_at();
  for(int i=0; i<n; i++)  
    rt[p[i].p-1]=p[p[i].p-1].bt;
  cout<<"\nEnter Time Quantum : "; 
  cin>>time_quantum;  
  for(int i=0,time=0; remain!=0;) 
  { 
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[2].algo,"irr");
	algo[2].avg_tat=(float)tot_tat/n;
	algo[2].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}

void irr_mean_tq(int menu_flag) 
{ 
	cout<<"\n\n#############  Improved Roud Robin with Mean Quantum Time  #############\n\n";
	assign();
  int remain=n, rt[n], time_quantum, tot_wt=0, tot_tat=0, flag=0, mean=0; 
  sort_at();
  for(int i=0; i<n; i++)  
    rt[p[i].p-1]=p[p[i].p-1].bt;  
  for(int i=0,time=0; remain!=0;) 
  { 
	mean=0;
  	for(int j=0; j<n; j++)
	  	mean+=p[j].rt;
	time_quantum = (mean/remain + 1) / 2;	
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    }
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[3].algo,"irr_mean_tq");
	algo[3].avg_tat=(float)tot_tat/n;
	algo[3].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();

}

void irr_min_tq(int menu_flag) 
{ 
	cout<<"\n\n#############  Improved ROund Robin with Min Quantum Time  #############\n\n";
	assign();
  int remain=n, rt[n], time_quantum, tot_wt=0, tot_tat=0, flag=0, mintq=1000; 
  sort_at();
  for(int i=0; i<n; i++)  
    rt[p[i].p-1]=p[p[i].p-1].bt;  
  for(int i=0,time=0; remain!=0;) 
  { 
  	mintq=1000;
  	for(int j=0; j<n; j++)
	  	if(mintq>p[j].rt and p[j].rt!=0)
	  		mintq=p[j].rt;
	time_quantum = mintq;	
    if(p[i].rt<=time_quantum && p[i].rt>0) 
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    } 
    else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
    { 
      time+=p[i].rt; 
      p[i].rt=0; 
      flag=1; 
    }
    else if(p[i].rt>0) 
    { 
      p[i].rt-=time_quantum; 
      time+=time_quantum; 
    } 
    if(p[i].rt==0 && flag==1) 
    { 
      remain--; 
      p[i].wt=time-p[i].at-p[i].bt;
	  p[i].tat=time-p[i].at;
      tot_wt+=p[i].wt; 
      tot_tat+=p[i].tat; 
      flag=0; 
    } 
    if(i==n-1) 
      i=0; 
    else if(p[i+1].at<=time) 
      i++; 
    else 
      i=0; 
  } 
  cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[4].algo,"irr_min_tq");
	algo[4].avg_tat=(float)tot_tat/n;
	algo[4].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}

void irrsjf(int menu_flag)
{
	cout<<"\n\n#############  Imporved Roubd Robin Shortest Job First  #############\n\n";
    int time_quantum,tot_tat=0, tot_wt=0;
    int remain=n;
    int time=0; 
	int old_mean=0;
    
    cout<<"\nEnter Time Quantum : "; 
	cin>>time_quantum;
    
    for(int i=0; i<n; i++)
		p[i].rt=p[i].bt;
	while(remain>0)
	{	
		//sorting in ascending order
		for(int i=0;i<n;i++)
			for(int j=0;j<n-i-1;j++)
				if(p[j].rt>p[j+1].rt)
				{
					temp=p[j+1];
					p[j+1]=p[j];
					p[j]=temp;
				}	
		for(int i=0;i<n;i++) //loop main
		{
			if(p[i].at<=time && p[i].rt!=0)
    		{
        		if(p[i].rt<time_quantum && p[i].rt!=0)
    			{
			        time+=p[i].rt;
			        p[i].rt=0;
    			}
        		else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
			    { 
			      time+=p[i].rt; 
			      p[i].rt=0;  
			    }
				else
   		 		{
			        time+=time_quantum;
			        p[i].rt-=time_quantum;
    			}
        		
				if(p[i].rt==0)
    			{
			        p[i].wt=time-p[i].bt-p[i].at;
			        p[i].tat=time-p[i].at;
					remain--;
    			}
    		}
		}
	}
	for(int i=0; i<n; i++)
	{
		tot_wt += p[i].wt;
		tot_tat += p[i].tat; 
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[5].algo,"irr_sjf");
	algo[5].avg_tat=(float)tot_tat/n;
	algo[5].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}



void irrsjfdtq(int menu_flag)
{
	cout<<"\n\n#############  Improved Round Robin Shortest Job First with Dynamic Quantum Time  #############\n\n";
    int time_quantum,tot_tat=0, tot_wt=0;
    int remain=n;
    int time=0;
    int max_bt;
    int sum_bt,prq;  // prq = process in ready queue
	int old_mean=0;
    
    for(int i=0; i<n; i++)
    {	
		p[i].rt=p[i].bt;
		old_mean+=p[i].bt;
	}
	old_mean/=n;
	while(remain>0)
	{
		//sorting in ascending order
		for(int i=0;i<n;i++)
			for(int j=0;j<n-i-1;j++)
				if(p[j].rt>p[j+1].rt)
				{
					temp=p[j+1];
					p[j+1]=p[j];
					p[j]=temp;
				}	
		for(int i=0;i<n;i++) //loop main
		{
			prq=0;  
        	max_bt=0;
        	sum_bt=0;
    		for(int j=0;j<n;j++)
	    	{
				if(p[j].at<=time && p[j].rt!=0)
				{
	        		prq++;
	        		if(p[j].rt>max_bt)
	            		max_bt=p[j].rt;
	        		sum_bt+=p[j].rt;
	    		}
	    	}
	    	
			if(prq==0 ||  (sum_bt/prq) == 0)
	    		time_quantum = old_mean;
	    	else
	    	{
				time_quantum=sum_bt/prq;
				old_mean = time_quantum;
			}
			if(p[i].at<=time && p[i].rt!=0)
    		{
        		if(p[i].rt<time_quantum && p[i].rt!=0)
    			{
			        time+=p[i].rt;
			        p[i].rt=0;
    			}
        		else if(p[i].rt>time_quantum && p[i].rt>0 && time_quantum*2-p[i].rt>=0)
			    { 
			      time+=p[i].rt; 
			      p[i].rt=0;  
			    }
				else
   		 		{
			        time+=time_quantum;
			        p[i].rt-=time_quantum;
    			}
        		
				if(p[i].rt==0)
    			{
			        p[i].wt=time-p[i].bt-p[i].at;
			        p[i].tat=time-p[i].at;
					remain--;
    			}
    		}
		}
	}
	for(int i=0; i<n; i++)
	{
		tot_wt += p[i].wt;
		tot_tat += p[i].tat; 
	}
	cout<<"Process    Burst Time    Arrival Time    Waiting Time    Turn Around Time\n";
	for(int i=0; i<n; i++)
		cout<<"   "<<p[i].p<<"\t\t"<<p[i].bt<<"\t\t"<<p[i].at<<"\t\t"<<p[i].wt<<"\t\t"<<p[i].tat<<"\n";
	cout<<"\nAverage Waiting Time = "<<(float)tot_wt/n;
	cout<<"\nAverage Turn Around Time = "<<(float)tot_tat/n<<"\n"; 
	strcpy(algo[6].algo,"irr_sjf_dtq");
	algo[6].avg_tat=(float)tot_tat/n;
	algo[6].avg_wt=(float)tot_wt/n;
	if(menu_flag)
		menu();
}


 




























